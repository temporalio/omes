// @generated
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataBlob {
    #[prost(enumeration="super::super::enums::v1::EncodingType", tag="1")]
    pub encoding_type: i32,
    #[prost(bytes="vec", tag="2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// See `Payload`
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payloads {
    #[prost(message, repeated, tag="1")]
    pub payloads: ::prost::alloc::vec::Vec<Payload>,
}
/// Represents some binary (byte array) data (ex: activity input parameters or workflow result) with
/// metadata which describes this binary data (format, encoding, encryption, etc). Serialization
/// of the data may be user-defined.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    #[prost(map="string, bytes", tag="1")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes="vec", tag="2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.
/// The payload is not serialized in a user-defined way.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAttributes {
    #[prost(map="string, message", tag="1")]
    pub indexed_fields: ::std::collections::HashMap<::prost::alloc::string::String, Payload>,
}
/// A user-defined set of *unindexed* fields that are exposed when listing/searching workflows
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Memo {
    #[prost(map="string, message", tag="1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Payload>,
}
/// Contains metadata that can be attached to a variety of requests, like starting a workflow, and
/// can be propagated between, for example, workflows and activities.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    #[prost(map="string, message", tag="1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Payload>,
}
/// Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
/// uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
/// run id as a way of saying "target the latest run of the workflow".
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecution {
    #[prost(string, tag="1")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub run_id: ::prost::alloc::string::String,
}
/// Represents the identifier used by a workflow author to define the workflow. Typically, the
/// name of a function. This is sometimes referred to as the workflow's "name"
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowType {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents the identifier used by a activity author to define the activity. Typically, the
/// name of a function. This is sometimes referred to as the activity's "name"
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityType {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
/// How retries ought to be handled, usable by both workflows and activities
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryPolicy {
    /// Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries.
    #[prost(message, optional, tag="1")]
    pub initial_interval: ::core::option::Option<::prost_types::Duration>,
    /// Coefficient used to calculate the next retry interval.
    /// The next retry interval is previous interval multiplied by the coefficient.
    /// Must be 1 or larger.
    #[prost(double, tag="2")]
    pub backoff_coefficient: f64,
    /// Maximum interval between retries. Exponential backoff leads to interval increase.
    /// This value is the cap of the increase. Default is 100x of the initial interval.
    #[prost(message, optional, tag="3")]
    pub maximum_interval: ::core::option::Option<::prost_types::Duration>,
    /// Maximum number of attempts. When exceeded the retries stop even if not expired yet.
    /// 1 disables retries. 0 means unlimited (up to the timeouts)
    #[prost(int32, tag="4")]
    pub maximum_attempts: i32,
    /// Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that
    /// this is not a substring match, the error *type* (not message) must match exactly.
    #[prost(string, repeated, tag="5")]
    pub non_retryable_error_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Metadata relevant for metering purposes
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MeteringMetadata {
    /// Count of local activities which have begun an execution attempt during this workflow task,
    /// and whose first attempt occurred in some previous task. This is used for metering
    /// purposes, and does not affect workflow state.
    ///
    /// (-- api-linter: core::0141::forbidden-types=disabled
    ///      aip.dev/not-precedent: Negative values make no sense to represent. --)
    #[prost(uint32, tag="13")]
    pub nonfirst_local_activity_execution_attempts: u32,
}
/// Deprecated. This message is replaced with `Deployment` and `VersioningBehavior`.
/// Identifies the version(s) of a worker that processed a task
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerVersionStamp {
    /// An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this
    /// message is included in requests which previously used that.
    #[prost(string, tag="1")]
    pub build_id: ::prost::alloc::string::String,
    /// If set, the worker is opting in to worker versioning. Otherwise, this is used only as a
    /// marker for workflow reset points and the BuildIDs search attribute.
    #[prost(bool, tag="3")]
    pub use_versioning: bool,
}
/// Identifies the version that a worker is compatible with when polling or identifying itself,
/// and whether or not this worker is opting into the build-id based versioning feature. This is
/// used by matching to determine which workers ought to receive what tasks.
/// Deprecated. Use WorkerDeploymentOptions instead.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerVersionCapabilities {
    /// An opaque whole-worker identifier
    #[prost(string, tag="1")]
    pub build_id: ::prost::alloc::string::String,
    /// If set, the worker is opting in to worker versioning, and wishes to only receive appropriate
    /// tasks.
    #[prost(bool, tag="2")]
    pub use_versioning: bool,
    /// Must be sent if user has set a deployment series name (versioning-3).
    #[prost(string, tag="4")]
    pub deployment_series_name: ::prost::alloc::string::String,
}
/// Describes where and how to reset a workflow, used for batch reset currently
/// and may be used for single-workflow reset later.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetOptions {
    /// Deprecated. Use `options`.
    /// Default: RESET_REAPPLY_TYPE_SIGNAL
    #[deprecated]
    #[prost(enumeration="super::super::enums::v1::ResetReapplyType", tag="10")]
    pub reset_reapply_type: i32,
    /// If true, limit the reset to only within the current run. (Applies to build_id targets and
    /// possibly others in the future.)
    #[prost(bool, tag="11")]
    pub current_run_only: bool,
    /// Event types not to be reapplied
    #[prost(enumeration="super::super::enums::v1::ResetReapplyExcludeType", repeated, tag="12")]
    pub reset_reapply_exclude_types: ::prost::alloc::vec::Vec<i32>,
    /// Which workflow task to reset to.
    #[prost(oneof="reset_options::Target", tags="1, 2, 3, 4")]
    pub target: ::core::option::Option<reset_options::Target>,
}
/// Nested message and enum types in `ResetOptions`.
pub mod reset_options {
    /// Which workflow task to reset to.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        /// Resets to the first workflow task completed or started event.
        #[prost(message, tag="1")]
        FirstWorkflowTask(()),
        /// Resets to the last workflow task completed or started event.
        #[prost(message, tag="2")]
        LastWorkflowTask(()),
        /// The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
        /// `WORKFLOW_TASK_STARTED` event to reset to.
        /// Note that this option doesn't make sense when used as part of a batch request.
        #[prost(int64, tag="3")]
        WorkflowTaskId(i64),
        /// Resets to the first workflow task processed by this build id.
        /// If the workflow was not processed by the build id, or the workflow task can't be
        /// determined, no reset will be performed.
        /// Note that by default, this reset is allowed to be to a prior run in a chain of
        /// continue-as-new.
        #[prost(string, tag="4")]
        BuildId(::prost::alloc::string::String),
    }
}
/// Callback to attach to various events in the system, e.g. workflow run completion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Callback {
    /// Links associated with the callback. It can be used to link to underlying resources of the
    /// callback.
    #[prost(message, repeated, tag="100")]
    pub links: ::prost::alloc::vec::Vec<Link>,
    #[prost(oneof="callback::Variant", tags="2, 3")]
    pub variant: ::core::option::Option<callback::Variant>,
}
/// Nested message and enum types in `Callback`.
pub mod callback {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Nexus {
        /// Callback URL.
        #[prost(string, tag="1")]
        pub url: ::prost::alloc::string::String,
        /// Header to attach to callback request.
        #[prost(map="string, string", tag="2")]
        pub header: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    }
    /// Callbacks to be delivered internally within the system.
    /// This variant is not settable in the API and will be rejected by the service with an INVALID_ARGUMENT error.
    /// The only reason that this is exposed is because callbacks are replicated across clusters via the
    /// WorkflowExecutionStarted event, which is defined in the public API.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Internal {
        /// Opaque internal data.
        #[prost(bytes="vec", tag="1")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Variant {
        #[prost(message, tag="2")]
        Nexus(Nexus),
        #[prost(message, tag="3")]
        Internal(Internal),
    }
}
/// Link can be associated with history events. It might contain information about an external entity
/// related to the history event. For example, workflow A makes a Nexus call that starts workflow B:
/// in this case, a history event in workflow A could contain a Link to the workflow started event in
/// workflow B, and vice-versa.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Link {
    #[prost(oneof="link::Variant", tags="1, 2")]
    pub variant: ::core::option::Option<link::Variant>,
}
/// Nested message and enum types in `Link`.
pub mod link {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WorkflowEvent {
        #[prost(string, tag="1")]
        pub namespace: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub workflow_id: ::prost::alloc::string::String,
        #[prost(string, tag="3")]
        pub run_id: ::prost::alloc::string::String,
        /// Additional information about the workflow event.
        /// Eg: the caller workflow can send the history event details that made the Nexus call.
        #[prost(oneof="workflow_event::Reference", tags="100, 101")]
        pub reference: ::core::option::Option<workflow_event::Reference>,
    }
    /// Nested message and enum types in `WorkflowEvent`.
    pub mod workflow_event {
        /// EventReference is a direct reference to a history event through the event ID.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct EventReference {
            #[prost(int64, tag="1")]
            pub event_id: i64,
            #[prost(enumeration="super::super::super::super::enums::v1::EventType", tag="2")]
            pub event_type: i32,
        }
        /// RequestIdReference is a indirect reference to a history event through the request ID.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RequestIdReference {
            #[prost(string, tag="1")]
            pub request_id: ::prost::alloc::string::String,
            #[prost(enumeration="super::super::super::super::enums::v1::EventType", tag="2")]
            pub event_type: i32,
        }
        /// Additional information about the workflow event.
        /// Eg: the caller workflow can send the history event details that made the Nexus call.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Reference {
            #[prost(message, tag="100")]
            EventRef(EventReference),
            #[prost(message, tag="101")]
            RequestIdRef(RequestIdReference),
        }
    }
    /// A link to a built-in batch job.
    /// Batch jobs can be used to perform operations on a set of workflows (e.g. terminate, signal, cancel, etc).
    /// This link can be put on workflow history events generated by actions taken by a batch job.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BatchJob {
        #[prost(string, tag="1")]
        pub job_id: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Variant {
        #[prost(message, tag="1")]
        WorkflowEvent(WorkflowEvent),
        #[prost(message, tag="2")]
        BatchJob(BatchJob),
    }
}
/// Priority contains metadata that controls relative ordering of task processing
/// when tasks are backed up in a queue. Initially, Priority will be used in
/// matching (workflow and activity) task queues. Later it may be used in history
/// task queues and in rate limiting decisions.
///
/// Priority is attached to workflows and activities. By default, activities
/// inherit Priority from the workflow that created them, but may override fields
/// when an activity is started or modified.
///
/// Despite being named "Priority", this message also contains fields that
/// control "fairness" mechanisms.
///
/// For all fields, the field not present or equal to zero/empty string means to
/// inherit the value from the calling workflow, or if there is no calling
/// workflow, then use the default value.
///
/// For all fields other than fairness_key, the zero value isn't meaningful so
/// there's no confusion between inherit/default and a meaningful value. For
/// fairness_key, the empty string will be interpreted as "inherit". This means
/// that if a workflow has a non-empty fairness key, you can't override the
/// fairness key of its activity to the empty string.
///
/// The overall semantics of Priority are:
/// 1. First, consider "priority": higher priority (lower number) goes first.
/// 2. Then, consider fairness: try to dispatch tasks for different fairness keys
///     in proportion to their weight.
///
/// Applications may use any subset of mechanisms that are useful to them and
/// leave the other fields to use default values.
///
/// Not all queues in the system may support the "full" semantics of all priority
/// fields. (Currently only support in matching task queues is planned.)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Priority {
    /// Priority key is a positive integer from 1 to n, where smaller integers
    /// correspond to higher priorities (tasks run sooner). In general, tasks in
    /// a queue should be processed in close to priority order, although small
    /// deviations are possible.
    ///
    /// The maximum priority value (minimum priority) is determined by server
    /// configuration, and defaults to 5.
    ///
    /// If priority is not present (or zero), then the effective priority will be
    /// the default priority, which is is calculated by (min+max)/2. With the
    /// default max of 5, and min of 1, that comes out to 3.
    #[prost(int32, tag="1")]
    pub priority_key: i32,
    /// Fairness key is a short string that's used as a key for a fairness
    /// balancing mechanism. It may correspond to a tenant id, or to a fixed
    /// string like "high" or "low". The default is the empty string.
    ///
    /// The fairness mechanism attempts to dispatch tasks for a given key in
    /// proportion to its weight. For example, using a thousand distinct tenant
    /// ids, each with a weight of 1.0 (the default) will result in each tenant
    /// getting a roughly equal share of task dispatch throughput.
    ///
    /// (Note: this does not imply equal share of worker capacity! Fairness
    /// decisions are made based on queue statistics, not
    /// current worker load.)
    ///
    /// As another example, using keys "high" and "low" with weight 9.0 and 1.0
    /// respectively will prefer dispatching "high" tasks over "low" tasks at a
    /// 9:1 ratio, while allowing either key to use all worker capacity if the
    /// other is not present.
    ///
    /// All fairness mechanisms, including rate limits, are best-effort and
    /// probabilistic. The results may not match what a "perfect" algorithm with
    /// infinite resources would produce. The more unique keys are used, the less
    /// accurate the results will be.
    ///
    /// Fairness keys are limited to 64 bytes.
    #[prost(string, tag="2")]
    pub fairness_key: ::prost::alloc::string::String,
    /// Fairness weight for a task can come from multiple sources for
    /// flexibility. From highest to lowest precedence:
    /// 1. Weights for a small set of keys can be overridden in task queue
    ///     configuration with an API.
    /// 2. It can be attached to the workflow/activity in this field.
    /// 3. The default weight of 1.0 will be used.
    ///
    /// Weight values are clamped to the range \[0.001, 1000\].
    #[prost(float, tag="3")]
    pub fairness_weight: f32,
}
/// This is used to send commands to a specific worker or a group of workers.
/// Right now, it is used to send commands to a specific worker instance.
/// Will be extended to be able to send command to multiple workers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerSelector {
    /// Options are:
    /// - query (will be used as query to ListWorkers, same format as in ListWorkersRequest.query)
    /// - task queue (just a shortcut. Same as query=' "TaskQueue"="my-task-queue" ')
    /// - etc.
    ///    All but 'query' are shortcuts, can be replaced with a query, but it is not convenient.
    /// string query = 5;
    /// string task_queue = 6;
    /// ...
    #[prost(oneof="worker_selector::Selector", tags="1")]
    pub selector: ::core::option::Option<worker_selector::Selector>,
}
/// Nested message and enum types in `WorkerSelector`.
pub mod worker_selector {
    /// Options are:
    /// - query (will be used as query to ListWorkers, same format as in ListWorkersRequest.query)
    /// - task queue (just a shortcut. Same as query=' "TaskQueue"="my-task-queue" ')
    /// - etc.
    ///    All but 'query' are shortcuts, can be replaced with a query, but it is not convenient.
    /// string query = 5;
    /// string task_queue = 6;
    /// ...
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Selector {
        /// Worker instance key to which the command should be sent.
        #[prost(string, tag="1")]
        WorkerInstanceKey(::prost::alloc::string::String),
    }
}
// @@protoc_insertion_point(module)
