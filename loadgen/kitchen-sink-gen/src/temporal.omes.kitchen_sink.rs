// @generated
// This file is @generated by prost-build.
/// The input to the test overall. A copy of this constitutes everything that is needed to reproduce
/// the test.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestInput {
    #[prost(message, optional, tag="1")]
    pub workflow_input: ::core::option::Option<WorkflowInput>,
    #[prost(message, optional, tag="2")]
    pub client_sequence: ::core::option::Option<ClientSequence>,
    /// Technically worker options should be known as well. We don't have any common format for that
    /// and creating one feels overkill to start with. Requiring the harness to print the config at
    /// startup seems good enough for now.
    #[prost(message, optional, tag="3")]
    pub with_start_action: ::core::option::Option<WithStartClientAction>,
}
/// All the client actions that will be taken over the course of this test
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientSequence {
    #[prost(message, repeated, tag="1")]
    pub action_sets: ::prost::alloc::vec::Vec<ClientActionSet>,
}
/// A set of client actions to execute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientActionSet {
    #[prost(message, repeated, tag="1")]
    pub actions: ::prost::alloc::vec::Vec<ClientAction>,
    #[prost(bool, tag="2")]
    pub concurrent: bool,
    /// Wait the specified amount of time at the end of the action set before proceeding to the next
    /// (if there is one, if not, ignored).
    #[prost(message, optional, tag="3")]
    pub wait_at_end: ::core::option::Option<::prost_types::Duration>,
    /// If set, the client should wait for the current run to end before proceeding (IE: the workflow
    /// is going to continue-as-new).
    #[prost(bool, tag="4")]
    pub wait_for_current_run_to_finish_at_end: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithStartClientAction {
    #[prost(oneof="with_start_client_action::Variant", tags="1, 2")]
    pub variant: ::core::option::Option<with_start_client_action::Variant>,
}
/// Nested message and enum types in `WithStartClientAction`.
pub mod with_start_client_action {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Variant {
        #[prost(message, tag="1")]
        DoSignal(super::DoSignal),
        #[prost(message, tag="2")]
        DoUpdate(super::DoUpdate),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientAction {
    #[prost(oneof="client_action::Variant", tags="1, 2, 3, 4")]
    pub variant: ::core::option::Option<client_action::Variant>,
}
/// Nested message and enum types in `ClientAction`.
pub mod client_action {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Variant {
        #[prost(message, tag="1")]
        DoSignal(super::DoSignal),
        #[prost(message, tag="2")]
        DoQuery(super::DoQuery),
        #[prost(message, tag="3")]
        DoUpdate(super::DoUpdate),
        #[prost(message, tag="4")]
        NestedActions(super::ClientActionSet),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoSignal {
    /// If set, the Signal is a Signal-with-Start.
    #[prost(bool, tag="3")]
    pub with_start: bool,
    #[prost(oneof="do_signal::Variant", tags="1, 2")]
    pub variant: ::core::option::Option<do_signal::Variant>,
}
/// Nested message and enum types in `DoSignal`.
pub mod do_signal {
    #[derive(::derive_more::From)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DoSignalActions {
        #[prost(oneof="do_signal_actions::Variant", tags="1, 2")]
        pub variant: ::core::option::Option<do_signal_actions::Variant>,
    }
    /// Nested message and enum types in `DoSignalActions`.
    pub mod do_signal_actions {
        #[derive(::derive_more::From)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Variant {
            /// Execute the action set in the handler. Since Go doesn't have explicit signal handlers it
            /// should instead run the actions in a goroutine for both of these variants, as the
            /// distinction doesn't really matter there.
            #[prost(message, tag="1")]
            DoActions(super::super::ActionSet),
            /// Pipe the actions back to the main workflow function via a queue or similar mechanism, where
            /// they will then be run.
            #[prost(message, tag="2")]
            DoActionsInMain(super::super::ActionSet),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Variant {
        /// A signal handler must exist named `do_actions_signal` which is responsible for handling the
        /// DoSignalActions message. See it's doc for details.
        #[prost(message, tag="1")]
        DoSignalActions(DoSignalActions),
        /// Send an arbitrary signal
        #[prost(message, tag="2")]
        Custom(super::HandlerInvocation),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoQuery {
    /// If set, the client should expect the query to fail
    #[prost(bool, tag="10")]
    pub failure_expected: bool,
    #[prost(oneof="do_query::Variant", tags="1, 2")]
    pub variant: ::core::option::Option<do_query::Variant>,
}
/// Nested message and enum types in `DoQuery`.
pub mod do_query {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Variant {
        /// A query must exist named `report_state` which returns the `WorkflowState` message. The input
        /// is pointless and only exists to allow testing of variably-sized query args.
        #[prost(message, tag="1")]
        ReportState(super::super::super::api::common::v1::Payloads),
        /// Send an arbitrary query
        #[prost(message, tag="2")]
        Custom(super::HandlerInvocation),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoUpdate {
    /// If set, the Update is an Update-with-Start.
    #[prost(bool, tag="3")]
    pub with_start: bool,
    /// If set, the client should expect the update to fail
    #[prost(bool, tag="10")]
    pub failure_expected: bool,
    #[prost(oneof="do_update::Variant", tags="1, 2")]
    pub variant: ::core::option::Option<do_update::Variant>,
}
/// Nested message and enum types in `DoUpdate`.
pub mod do_update {
    #[derive(::derive_more::From)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Variant {
        /// An update must exist named `do_actions_update` which handles the `DoActionsUpdate` message.
        /// See message doc for what it should do.
        #[prost(message, tag="1")]
        DoActions(super::DoActionsUpdate),
        /// Send an arbitrary update request
        #[prost(message, tag="2")]
        Custom(super::HandlerInvocation),
    }
}
#[derive(::derive_more::From)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoActionsUpdate {
    #[prost(oneof="do_actions_update::Variant", tags="1, 2")]
    pub variant: ::core::option::Option<do_actions_update::Variant>,
}
/// Nested message and enum types in `DoActionsUpdate`.
pub mod do_actions_update {
    #[derive(::derive_more::From)]
    #[derive(::derive_more::From)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Variant {
        /// Do same thing signal handler would do when given the provided action set. The handler should
        /// return the `WorkflowState` when done with all the provided actions. You may also include a
        /// `ReturnErrorAction` or `ContinueAsNewAction` in the set to exit the handler in those ways.
        #[prost(message, tag="1")]
        DoActions(super::ActionSet),
        /// The validator should reject the update
        #[prost(message, tag="2")]
        RejectMe(()),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HandlerInvocation {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="2")]
    pub args: ::prost::alloc::vec::Vec<super::super::api::common::v1::Payload>,
}
/// Each workflow must maintain an instance of this state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowState {
    #[prost(map="string, string", tag="1")]
    pub kvs: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowInput {
    #[prost(message, repeated, tag="1")]
    pub initial_actions: ::prost::alloc::vec::Vec<ActionSet>,
}
/// A set of actions to execute concurrently or sequentially. It is necessary to be able to represent
/// sequential execution without multiple 1-size action sets, as that implies the receipt of a signal
/// between each of those sets, which may not be desired.
///
/// All actions are handled before proceeding to the next action set, unless one of those actions
/// would cause the workflow to complete/fail/CAN.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionSet {
    #[prost(message, repeated, tag="1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    #[prost(bool, tag="2")]
    pub concurrent: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(oneof="action::Variant", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15")]
    pub variant: ::core::option::Option<action::Variant>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[derive(::derive_more::From)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Variant {
        #[prost(message, tag="1")]
        Timer(super::TimerAction),
        #[prost(message, tag="2")]
        ExecActivity(super::ExecuteActivityAction),
        #[prost(message, tag="3")]
        ExecChildWorkflow(super::ExecuteChildWorkflowAction),
        #[prost(message, tag="4")]
        AwaitWorkflowState(super::AwaitWorkflowState),
        #[prost(message, tag="5")]
        SendSignal(super::SendSignalAction),
        #[prost(message, tag="6")]
        CancelWorkflow(super::CancelWorkflowAction),
        #[prost(message, tag="7")]
        SetPatchMarker(::prost::alloc::boxed::Box<super::SetPatchMarkerAction>),
        #[prost(message, tag="8")]
        UpsertSearchAttributes(super::UpsertSearchAttributesAction),
        #[prost(message, tag="9")]
        UpsertMemo(super::UpsertMemoAction),
        #[prost(message, tag="10")]
        SetWorkflowState(super::WorkflowState),
        #[prost(message, tag="11")]
        ReturnResult(super::ReturnResultAction),
        #[prost(message, tag="12")]
        ReturnError(super::ReturnErrorAction),
        #[prost(message, tag="13")]
        ContinueAsNew(super::ContinueAsNewAction),
        #[prost(message, tag="14")]
        NestedActionSet(super::ActionSet),
        #[prost(message, tag="15")]
        NexusOperation(super::ExecuteNexusOperation),
    }
}
// The following actions and the messages they depend on are largely duplicative of Core/Server's
// commands, but some care is taken to remove things that would be uninteresting for these tests.

/// All await commands will have this available as a field. If it is set, the command
/// should be either awaited upon, cancelled, or abandoned at the specified juncture (if possible,
/// not all command types will be cancellable at all stages. Is is up to the generator to produce
/// valid conditions).
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AwaitableChoice {
    #[prost(oneof="awaitable_choice::Condition", tags="1, 2, 3, 4, 5")]
    pub condition: ::core::option::Option<awaitable_choice::Condition>,
}
/// Nested message and enum types in `AwaitableChoice`.
pub mod awaitable_choice {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Condition {
        /// Wait for the command to finish. This is the default.
        #[prost(message, tag="1")]
        WaitFinish(()),
        /// Call the command API but immediately move on. IE: Don't await on it at all.
        #[prost(message, tag="2")]
        Abandon(()),
        /// Cancel the command before it's begun - IE: Cancel it immediately after starting it with
        /// no await, within the same workflow task.
        #[prost(message, tag="3")]
        CancelBeforeStarted(()),
        /// Cancel the command after it's been started. Not all SDKs will know when a command is started
        /// and in those cases they should issue the cancellation in the next workflow task after
        /// creating the command.
        #[prost(message, tag="4")]
        CancelAfterStarted(()),
        /// Cancel the command after it's already completed.
        #[prost(message, tag="5")]
        CancelAfterCompleted(()),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimerAction {
    #[prost(uint64, tag="1")]
    pub milliseconds: u64,
    #[prost(message, optional, tag="2")]
    pub awaitable_choice: ::core::option::Option<AwaitableChoice>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteActivityAction {
    /// The name of the task queue to place this activity request in
    #[prost(string, tag="4")]
    pub task_queue: ::prost::alloc::string::String,
    #[prost(map="string, message", tag="5")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, super::super::api::common::v1::Payload>,
    /// Indicates how long the caller is willing to wait for an activity completion. Limits how long
    /// retries will be attempted. Either this or start_to_close_timeout_seconds must be specified.
    /// When not specified defaults to the workflow execution timeout.
    #[prost(message, optional, tag="6")]
    pub schedule_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Limits time an activity task can stay in a task queue before a worker picks it up. This
    /// timeout is always non retryable as all a retry would achieve is to put it back into the same
    /// queue. Defaults to schedule_to_close_timeout or workflow execution timeout if not specified.
    #[prost(message, optional, tag="7")]
    pub schedule_to_start_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Maximum time an activity is allowed to execute after a pick up by a worker. This timeout is
    /// always retryable. Either this or schedule_to_close_timeout must be specified.
    #[prost(message, optional, tag="8")]
    pub start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Maximum time allowed between successful worker heartbeats.
    #[prost(message, optional, tag="9")]
    pub heartbeat_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Activities are provided by a default retry policy controlled through the service dynamic
    /// configuration. Retries are happening up to schedule_to_close_timeout. To disable retries set
    /// retry_policy.maximum_attempts to 1.
    #[prost(message, optional, tag="10")]
    pub retry_policy: ::core::option::Option<super::super::api::common::v1::RetryPolicy>,
    #[prost(message, optional, tag="13")]
    pub awaitable_choice: ::core::option::Option<AwaitableChoice>,
    #[prost(message, optional, tag="15")]
    pub priority: ::core::option::Option<super::super::api::common::v1::Priority>,
    /// TODO: once complete, use commonpb.PriorityKey instead
    #[prost(string, tag="16")]
    pub fairness_key: ::prost::alloc::string::String,
    #[prost(float, tag="17")]
    pub fairness_weight: f32,
    #[prost(oneof="execute_activity_action::ActivityType", tags="1, 2, 3, 14, 18")]
    pub activity_type: ::core::option::Option<execute_activity_action::ActivityType>,
    /// Whether or not this activity will be a local activity
    #[prost(oneof="execute_activity_action::Locality", tags="11, 12")]
    pub locality: ::core::option::Option<execute_activity_action::Locality>,
}
/// Nested message and enum types in `ExecuteActivityAction`.
pub mod execute_activity_action {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GenericActivity {
        #[prost(string, tag="1")]
        pub r#type: ::prost::alloc::string::String,
        #[prost(message, repeated, tag="2")]
        pub arguments: ::prost::alloc::vec::Vec<super::super::super::api::common::v1::Payload>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ResourcesActivity {
        #[prost(message, optional, tag="1")]
        pub run_for: ::core::option::Option<::prost_types::Duration>,
        #[prost(uint64, tag="2")]
        pub bytes_to_allocate: u64,
        #[prost(uint32, tag="3")]
        pub cpu_yield_every_n_iterations: u32,
        #[prost(uint32, tag="4")]
        pub cpu_yield_for_ms: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PayloadActivity {
        #[prost(int32, tag="1")]
        pub bytes_to_receive: i32,
        #[prost(int32, tag="2")]
        pub bytes_to_return: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ActivityType {
        #[prost(message, tag="1")]
        Generic(GenericActivity),
        /// There must be an activity named `delay` which accepts some kind of duration and waits
        /// for that long
        #[prost(message, tag="2")]
        Delay(::prost_types::Duration),
        /// There must be an activity named `noop` which does nothing
        #[prost(message, tag="3")]
        Noop(()),
        /// There must be an activity named `resources` which accepts the ResourcesActivity message as input
        #[prost(message, tag="14")]
        Resources(ResourcesActivity),
        /// There must be an activity named `payload` which accepts the PayloadActivity message as input
        #[prost(message, tag="18")]
        Payload(PayloadActivity),
    }
    /// Whether or not this activity will be a local activity
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Locality {
        #[prost(message, tag="11")]
        IsLocal(()),
        #[prost(message, tag="12")]
        Remote(super::RemoteActivityOptions),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteChildWorkflowAction {
    #[prost(string, tag="2")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub workflow_type: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub task_queue: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="6")]
    pub input: ::prost::alloc::vec::Vec<super::super::api::common::v1::Payload>,
    /// Total workflow execution timeout including retries and continue as new.
    #[prost(message, optional, tag="7")]
    pub workflow_execution_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow run.
    #[prost(message, optional, tag="8")]
    pub workflow_run_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow task.
    #[prost(message, optional, tag="9")]
    pub workflow_task_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Default: PARENT_CLOSE_POLICY_TERMINATE.
    #[prost(enumeration="ParentClosePolicy", tag="10")]
    pub parent_close_policy: i32,
    /// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    #[prost(enumeration="super::super::api::enums::v1::WorkflowIdReusePolicy", tag="12")]
    pub workflow_id_reuse_policy: i32,
    #[prost(message, optional, tag="13")]
    pub retry_policy: ::core::option::Option<super::super::api::common::v1::RetryPolicy>,
    #[prost(string, tag="14")]
    pub cron_schedule: ::prost::alloc::string::String,
    /// Header fields
    #[prost(map="string, message", tag="15")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, super::super::api::common::v1::Payload>,
    /// Memo fields
    #[prost(map="string, message", tag="16")]
    pub memo: ::std::collections::HashMap<::prost::alloc::string::String, super::super::api::common::v1::Payload>,
    /// Search attributes
    #[prost(map="string, message", tag="17")]
    pub search_attributes: ::std::collections::HashMap<::prost::alloc::string::String, super::super::api::common::v1::Payload>,
    /// Defines behaviour of the underlying workflow when child workflow cancellation has been requested.
    #[prost(enumeration="ChildWorkflowCancellationType", tag="18")]
    pub cancellation_type: i32,
    /// Whether this child should run on a worker with a compatible build id or not.
    #[prost(enumeration="VersioningIntent", tag="19")]
    pub versioning_intent: i32,
    #[prost(message, optional, tag="20")]
    pub awaitable_choice: ::core::option::Option<AwaitableChoice>,
}
/// Wait for the workflow state to have a matching k/v entry
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwaitWorkflowState {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendSignalAction {
    /// What workflow is being targeted
    #[prost(string, tag="1")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub run_id: ::prost::alloc::string::String,
    /// Name of the signal handler
    #[prost(string, tag="3")]
    pub signal_name: ::prost::alloc::string::String,
    /// Arguments for the handler
    #[prost(message, repeated, tag="4")]
    pub args: ::prost::alloc::vec::Vec<super::super::api::common::v1::Payload>,
    /// Headers to attach to the signal
    #[prost(map="string, message", tag="5")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, super::super::api::common::v1::Payload>,
    #[prost(message, optional, tag="6")]
    pub awaitable_choice: ::core::option::Option<AwaitableChoice>,
}
/// Cancel an external workflow (may be a child)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelWorkflowAction {
    #[prost(string, tag="1")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub run_id: ::prost::alloc::string::String,
}
/// patched or getVersion API
/// For getVersion SDKs, use `DEFAULT_VERSION, 1` as the numeric arguments,
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPatchMarkerAction {
    /// A user-chosen identifier for this patch. If the same identifier is used in multiple places in
    /// the code, those places are considered to be versioned as one unit. IE: The check call will
    /// return the same result for all of them
    #[prost(string, tag="1")]
    pub patch_id: ::prost::alloc::string::String,
    /// TODO Not sure how we could use this in these tests
    /// Can be set to true to indicate that branches using this change are being removed, and all
    /// future worker deployments will only have the "with change" code in them.
    #[prost(bool, tag="2")]
    pub deprecated: bool,
    /// Perform this action behind the if guard
    #[prost(message, optional, boxed, tag="3")]
    pub inner_action: ::core::option::Option<::prost::alloc::boxed::Box<Action>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertSearchAttributesAction {
    /// SearchAttributes fields - equivalent to indexed_fields on api. Key = search index, Value =
    /// value
    #[prost(map="string, message", tag="1")]
    pub search_attributes: ::std::collections::HashMap<::prost::alloc::string::String, super::super::api::common::v1::Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertMemoAction {
    /// Update the workflow memo with the provided values. The values will be merged with
    /// the existing memo. If the user wants to delete values, a default/empty Payload should be
    /// used as the value for the key being deleted.
    #[prost(message, optional, tag="1")]
    pub upserted_memo: ::core::option::Option<super::super::api::common::v1::Memo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReturnResultAction {
    #[prost(message, optional, tag="1")]
    pub return_this: ::core::option::Option<super::super::api::common::v1::Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReturnErrorAction {
    #[prost(message, optional, tag="1")]
    pub failure: ::core::option::Option<super::super::api::failure::v1::Failure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContinueAsNewAction {
    /// The identifier the lang-specific sdk uses to execute workflow code
    #[prost(string, tag="1")]
    pub workflow_type: ::prost::alloc::string::String,
    /// Task queue for the new workflow execution
    #[prost(string, tag="2")]
    pub task_queue: ::prost::alloc::string::String,
    /// Inputs to the workflow code. Should be specified. Will not re-use old arguments, as that
    /// typically wouldn't make any sense.
    #[prost(message, repeated, tag="3")]
    pub arguments: ::prost::alloc::vec::Vec<super::super::api::common::v1::Payload>,
    /// Timeout for a single run of the new workflow. Will not re-use current workflow's value.
    #[prost(message, optional, tag="4")]
    pub workflow_run_timeout: ::core::option::Option<::prost_types::Duration>,
    /// Timeout of a single workflow task. Will not re-use current workflow's value.
    #[prost(message, optional, tag="5")]
    pub workflow_task_timeout: ::core::option::Option<::prost_types::Duration>,
    /// If set, the new workflow will have this memo. If unset, re-uses the current workflow's memo
    #[prost(map="string, message", tag="6")]
    pub memo: ::std::collections::HashMap<::prost::alloc::string::String, super::super::api::common::v1::Payload>,
    /// If set, the new workflow will have these headers. Will *not* re-use current workflow's
    /// headers otherwise.
    #[prost(map="string, message", tag="7")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, super::super::api::common::v1::Payload>,
    /// If set, the new workflow will have these search attributes. If unset, re-uses the current
    /// workflow's search attributes.
    #[prost(map="string, message", tag="8")]
    pub search_attributes: ::std::collections::HashMap<::prost::alloc::string::String, super::super::api::common::v1::Payload>,
    /// If set, the new workflow will have this retry policy. If unset, re-uses the current
    /// workflow's retry policy.
    #[prost(message, optional, tag="9")]
    pub retry_policy: ::core::option::Option<super::super::api::common::v1::RetryPolicy>,
    /// Whether the continued workflow should run on a worker with a compatible build id or not.
    #[prost(enumeration="VersioningIntent", tag="10")]
    pub versioning_intent: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoteActivityOptions {
    /// Defines how the workflow will wait (or not) for cancellation of the activity to be confirmed
    #[prost(enumeration="ActivityCancellationType", tag="1")]
    pub cancellation_type: i32,
    /// If set, the worker will not tell the service that it can immediately start executing this
    /// activity. When unset/default, workers will always attempt to do so if activity execution
    /// slots are available.
    #[prost(bool, tag="2")]
    pub do_not_eagerly_execute: bool,
    /// Whether this activity should run on a worker with a compatible build id or not.
    #[prost(enumeration="VersioningIntent", tag="3")]
    pub versioning_intent: i32,
}
/// Execute a Nexus operation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteNexusOperation {
    #[prost(string, tag="1")]
    pub endpoint: ::prost::alloc::string::String,
    /// Operation name to call
    #[prost(string, tag="2")]
    pub operation: ::prost::alloc::string::String,
    /// Input payload for the operation
    #[prost(string, tag="3")]
    pub input: ::prost::alloc::string::String,
    /// Headers to send with the operation
    #[prost(map="string, string", tag="4")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// How to await on the operation
    #[prost(message, optional, tag="5")]
    pub awaitable_choice: ::core::option::Option<AwaitableChoice>,
    /// Expected output for verification
    #[prost(string, tag="6")]
    pub expected_output: ::prost::alloc::string::String,
}
/// Used by the service to determine the fate of a child workflow
/// in case its parent is closed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParentClosePolicy {
    /// Let's the server set the default.
    Unspecified = 0,
    /// Terminate means terminating the child workflow.
    Terminate = 1,
    /// Abandon means not doing anything on the child workflow.
    Abandon = 2,
    /// Cancel means requesting cancellation on the child workflow.
    RequestCancel = 3,
}
impl ParentClosePolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PARENT_CLOSE_POLICY_UNSPECIFIED",
            Self::Terminate => "PARENT_CLOSE_POLICY_TERMINATE",
            Self::Abandon => "PARENT_CLOSE_POLICY_ABANDON",
            Self::RequestCancel => "PARENT_CLOSE_POLICY_REQUEST_CANCEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARENT_CLOSE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
            "PARENT_CLOSE_POLICY_TERMINATE" => Some(Self::Terminate),
            "PARENT_CLOSE_POLICY_ABANDON" => Some(Self::Abandon),
            "PARENT_CLOSE_POLICY_REQUEST_CANCEL" => Some(Self::RequestCancel),
            _ => None,
        }
    }
}
/// An indication of user's intent concerning what Build ID versioning approach should be used for
/// a specific command
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VersioningIntent {
    /// Indicates that core should choose the most sensible default behavior for the type of
    /// command, accounting for whether the command will be run on the same task queue as the current
    /// worker.
    Unspecified = 0,
    /// Indicates that the command should run on a worker with compatible version if possible. It may
    /// not be possible if the target task queue does not also have knowledge of the current worker's
    /// build ID.
    Compatible = 1,
    /// Indicates that the command should run on the target task queue's current overall-default
    /// build ID.
    Default = 2,
}
impl VersioningIntent {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNSPECIFIED",
            Self::Compatible => "COMPATIBLE",
            Self::Default => "DEFAULT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "COMPATIBLE" => Some(Self::Compatible),
            "DEFAULT" => Some(Self::Default),
            _ => None,
        }
    }
}
/// Controls at which point to report back to lang when a child workflow is cancelled
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChildWorkflowCancellationType {
    /// Do not request cancellation of the child workflow if already scheduled
    ChildWfAbandon = 0,
    /// Initiate a cancellation request and immediately report cancellation to the parent.
    ChildWfTryCancel = 1,
    /// Wait for child cancellation completion.
    ChildWfWaitCancellationCompleted = 2,
    /// Request cancellation of the child and wait for confirmation that the request was received.
    ChildWfWaitCancellationRequested = 3,
}
impl ChildWorkflowCancellationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ChildWfAbandon => "CHILD_WF_ABANDON",
            Self::ChildWfTryCancel => "CHILD_WF_TRY_CANCEL",
            Self::ChildWfWaitCancellationCompleted => "CHILD_WF_WAIT_CANCELLATION_COMPLETED",
            Self::ChildWfWaitCancellationRequested => "CHILD_WF_WAIT_CANCELLATION_REQUESTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHILD_WF_ABANDON" => Some(Self::ChildWfAbandon),
            "CHILD_WF_TRY_CANCEL" => Some(Self::ChildWfTryCancel),
            "CHILD_WF_WAIT_CANCELLATION_COMPLETED" => Some(Self::ChildWfWaitCancellationCompleted),
            "CHILD_WF_WAIT_CANCELLATION_REQUESTED" => Some(Self::ChildWfWaitCancellationRequested),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActivityCancellationType {
    /// Initiate a cancellation request and immediately report cancellation to the workflow.
    TryCancel = 0,
    /// Wait for activity cancellation completion. Note that activity must heartbeat to receive a
    /// cancellation notification. This can block the cancellation for a long time if activity
    /// doesn't heartbeat or chooses to ignore the cancellation request.
    WaitCancellationCompleted = 1,
    /// Do not request cancellation of the activity and immediately report cancellation to the
    /// workflow
    Abandon = 2,
}
impl ActivityCancellationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TryCancel => "TRY_CANCEL",
            Self::WaitCancellationCompleted => "WAIT_CANCELLATION_COMPLETED",
            Self::Abandon => "ABANDON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRY_CANCEL" => Some(Self::TryCancel),
            "WAIT_CANCELLATION_COMPLETED" => Some(Self::WaitCancellationCompleted),
            "ABANDON" => Some(Self::Abandon),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
