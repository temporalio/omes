// @generated
// This file is @generated by prost-build.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BatchOperationType {
    Unspecified = 0,
    Terminate = 1,
    Cancel = 2,
    Signal = 3,
    Delete = 4,
    Reset = 5,
    UpdateExecutionOptions = 6,
    UnpauseActivity = 7,
    UpdateActivityOptions = 8,
    ResetActivity = 9,
}
impl BatchOperationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BATCH_OPERATION_TYPE_UNSPECIFIED",
            Self::Terminate => "BATCH_OPERATION_TYPE_TERMINATE",
            Self::Cancel => "BATCH_OPERATION_TYPE_CANCEL",
            Self::Signal => "BATCH_OPERATION_TYPE_SIGNAL",
            Self::Delete => "BATCH_OPERATION_TYPE_DELETE",
            Self::Reset => "BATCH_OPERATION_TYPE_RESET",
            Self::UpdateExecutionOptions => "BATCH_OPERATION_TYPE_UPDATE_EXECUTION_OPTIONS",
            Self::UnpauseActivity => "BATCH_OPERATION_TYPE_UNPAUSE_ACTIVITY",
            Self::UpdateActivityOptions => "BATCH_OPERATION_TYPE_UPDATE_ACTIVITY_OPTIONS",
            Self::ResetActivity => "BATCH_OPERATION_TYPE_RESET_ACTIVITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATCH_OPERATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "BATCH_OPERATION_TYPE_TERMINATE" => Some(Self::Terminate),
            "BATCH_OPERATION_TYPE_CANCEL" => Some(Self::Cancel),
            "BATCH_OPERATION_TYPE_SIGNAL" => Some(Self::Signal),
            "BATCH_OPERATION_TYPE_DELETE" => Some(Self::Delete),
            "BATCH_OPERATION_TYPE_RESET" => Some(Self::Reset),
            "BATCH_OPERATION_TYPE_UPDATE_EXECUTION_OPTIONS" => Some(Self::UpdateExecutionOptions),
            "BATCH_OPERATION_TYPE_UNPAUSE_ACTIVITY" => Some(Self::UnpauseActivity),
            "BATCH_OPERATION_TYPE_UPDATE_ACTIVITY_OPTIONS" => Some(Self::UpdateActivityOptions),
            "BATCH_OPERATION_TYPE_RESET_ACTIVITY" => Some(Self::ResetActivity),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BatchOperationState {
    Unspecified = 0,
    Running = 1,
    Completed = 2,
    Failed = 3,
}
impl BatchOperationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BATCH_OPERATION_STATE_UNSPECIFIED",
            Self::Running => "BATCH_OPERATION_STATE_RUNNING",
            Self::Completed => "BATCH_OPERATION_STATE_COMPLETED",
            Self::Failed => "BATCH_OPERATION_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BATCH_OPERATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "BATCH_OPERATION_STATE_RUNNING" => Some(Self::Running),
            "BATCH_OPERATION_STATE_COMPLETED" => Some(Self::Completed),
            "BATCH_OPERATION_STATE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Whenever this list of command types is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommandType {
    Unspecified = 0,
    ScheduleActivityTask = 1,
    RequestCancelActivityTask = 2,
    StartTimer = 3,
    CompleteWorkflowExecution = 4,
    FailWorkflowExecution = 5,
    CancelTimer = 6,
    CancelWorkflowExecution = 7,
    RequestCancelExternalWorkflowExecution = 8,
    RecordMarker = 9,
    ContinueAsNewWorkflowExecution = 10,
    StartChildWorkflowExecution = 11,
    SignalExternalWorkflowExecution = 12,
    UpsertWorkflowSearchAttributes = 13,
    ProtocolMessage = 14,
    ModifyWorkflowProperties = 16,
    ScheduleNexusOperation = 17,
    RequestCancelNexusOperation = 18,
}
impl CommandType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMMAND_TYPE_UNSPECIFIED",
            Self::ScheduleActivityTask => "COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK",
            Self::RequestCancelActivityTask => "COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK",
            Self::StartTimer => "COMMAND_TYPE_START_TIMER",
            Self::CompleteWorkflowExecution => "COMMAND_TYPE_COMPLETE_WORKFLOW_EXECUTION",
            Self::FailWorkflowExecution => "COMMAND_TYPE_FAIL_WORKFLOW_EXECUTION",
            Self::CancelTimer => "COMMAND_TYPE_CANCEL_TIMER",
            Self::CancelWorkflowExecution => "COMMAND_TYPE_CANCEL_WORKFLOW_EXECUTION",
            Self::RequestCancelExternalWorkflowExecution => "COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION",
            Self::RecordMarker => "COMMAND_TYPE_RECORD_MARKER",
            Self::ContinueAsNewWorkflowExecution => "COMMAND_TYPE_CONTINUE_AS_NEW_WORKFLOW_EXECUTION",
            Self::StartChildWorkflowExecution => "COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION",
            Self::SignalExternalWorkflowExecution => "COMMAND_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION",
            Self::UpsertWorkflowSearchAttributes => "COMMAND_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
            Self::ProtocolMessage => "COMMAND_TYPE_PROTOCOL_MESSAGE",
            Self::ModifyWorkflowProperties => "COMMAND_TYPE_MODIFY_WORKFLOW_PROPERTIES",
            Self::ScheduleNexusOperation => "COMMAND_TYPE_SCHEDULE_NEXUS_OPERATION",
            Self::RequestCancelNexusOperation => "COMMAND_TYPE_REQUEST_CANCEL_NEXUS_OPERATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMAND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK" => Some(Self::ScheduleActivityTask),
            "COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK" => Some(Self::RequestCancelActivityTask),
            "COMMAND_TYPE_START_TIMER" => Some(Self::StartTimer),
            "COMMAND_TYPE_COMPLETE_WORKFLOW_EXECUTION" => Some(Self::CompleteWorkflowExecution),
            "COMMAND_TYPE_FAIL_WORKFLOW_EXECUTION" => Some(Self::FailWorkflowExecution),
            "COMMAND_TYPE_CANCEL_TIMER" => Some(Self::CancelTimer),
            "COMMAND_TYPE_CANCEL_WORKFLOW_EXECUTION" => Some(Self::CancelWorkflowExecution),
            "COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION" => Some(Self::RequestCancelExternalWorkflowExecution),
            "COMMAND_TYPE_RECORD_MARKER" => Some(Self::RecordMarker),
            "COMMAND_TYPE_CONTINUE_AS_NEW_WORKFLOW_EXECUTION" => Some(Self::ContinueAsNewWorkflowExecution),
            "COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION" => Some(Self::StartChildWorkflowExecution),
            "COMMAND_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION" => Some(Self::SignalExternalWorkflowExecution),
            "COMMAND_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES" => Some(Self::UpsertWorkflowSearchAttributes),
            "COMMAND_TYPE_PROTOCOL_MESSAGE" => Some(Self::ProtocolMessage),
            "COMMAND_TYPE_MODIFY_WORKFLOW_PROPERTIES" => Some(Self::ModifyWorkflowProperties),
            "COMMAND_TYPE_SCHEDULE_NEXUS_OPERATION" => Some(Self::ScheduleNexusOperation),
            "COMMAND_TYPE_REQUEST_CANCEL_NEXUS_OPERATION" => Some(Self::RequestCancelNexusOperation),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncodingType {
    Unspecified = 0,
    Proto3 = 1,
    Json = 2,
}
impl EncodingType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODING_TYPE_UNSPECIFIED",
            Self::Proto3 => "ENCODING_TYPE_PROTO3",
            Self::Json => "ENCODING_TYPE_JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODING_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ENCODING_TYPE_PROTO3" => Some(Self::Proto3),
            "ENCODING_TYPE_JSON" => Some(Self::Json),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexedValueType {
    Unspecified = 0,
    Text = 1,
    Keyword = 2,
    Int = 3,
    Double = 4,
    Bool = 5,
    Datetime = 6,
    KeywordList = 7,
}
impl IndexedValueType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INDEXED_VALUE_TYPE_UNSPECIFIED",
            Self::Text => "INDEXED_VALUE_TYPE_TEXT",
            Self::Keyword => "INDEXED_VALUE_TYPE_KEYWORD",
            Self::Int => "INDEXED_VALUE_TYPE_INT",
            Self::Double => "INDEXED_VALUE_TYPE_DOUBLE",
            Self::Bool => "INDEXED_VALUE_TYPE_BOOL",
            Self::Datetime => "INDEXED_VALUE_TYPE_DATETIME",
            Self::KeywordList => "INDEXED_VALUE_TYPE_KEYWORD_LIST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDEXED_VALUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INDEXED_VALUE_TYPE_TEXT" => Some(Self::Text),
            "INDEXED_VALUE_TYPE_KEYWORD" => Some(Self::Keyword),
            "INDEXED_VALUE_TYPE_INT" => Some(Self::Int),
            "INDEXED_VALUE_TYPE_DOUBLE" => Some(Self::Double),
            "INDEXED_VALUE_TYPE_BOOL" => Some(Self::Bool),
            "INDEXED_VALUE_TYPE_DATETIME" => Some(Self::Datetime),
            "INDEXED_VALUE_TYPE_KEYWORD_LIST" => Some(Self::KeywordList),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    Unspecified = 0,
    High = 1,
    Medium = 2,
    Low = 3,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEVERITY_UNSPECIFIED",
            Self::High => "SEVERITY_HIGH",
            Self::Medium => "SEVERITY_MEDIUM",
            Self::Low => "SEVERITY_LOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "SEVERITY_HIGH" => Some(Self::High),
            "SEVERITY_MEDIUM" => Some(Self::Medium),
            "SEVERITY_LOW" => Some(Self::Low),
            _ => None,
        }
    }
}
/// State of a callback.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CallbackState {
    /// Default value, unspecified state.
    Unspecified = 0,
    /// Callback is standing by, waiting to be triggered.
    Standby = 1,
    /// Callback is in the queue waiting to be executed or is currently executing.
    Scheduled = 2,
    /// Callback has failed with a retryable error and is backing off before the next attempt.
    BackingOff = 3,
    /// Callback has failed.
    Failed = 4,
    /// Callback has succeeded.
    Succeeded = 5,
    /// Callback is blocked (eg: by circuit breaker).
    Blocked = 6,
}
impl CallbackState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CALLBACK_STATE_UNSPECIFIED",
            Self::Standby => "CALLBACK_STATE_STANDBY",
            Self::Scheduled => "CALLBACK_STATE_SCHEDULED",
            Self::BackingOff => "CALLBACK_STATE_BACKING_OFF",
            Self::Failed => "CALLBACK_STATE_FAILED",
            Self::Succeeded => "CALLBACK_STATE_SUCCEEDED",
            Self::Blocked => "CALLBACK_STATE_BLOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CALLBACK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "CALLBACK_STATE_STANDBY" => Some(Self::Standby),
            "CALLBACK_STATE_SCHEDULED" => Some(Self::Scheduled),
            "CALLBACK_STATE_BACKING_OFF" => Some(Self::BackingOff),
            "CALLBACK_STATE_FAILED" => Some(Self::Failed),
            "CALLBACK_STATE_SUCCEEDED" => Some(Self::Succeeded),
            "CALLBACK_STATE_BLOCKED" => Some(Self::Blocked),
            _ => None,
        }
    }
}
/// State of a pending Nexus operation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PendingNexusOperationState {
    /// Default value, unspecified state.
    Unspecified = 0,
    /// Operation is in the queue waiting to be executed or is currently executing.
    Scheduled = 1,
    /// Operation has failed with a retryable error and is backing off before the next attempt.
    BackingOff = 2,
    /// Operation was started and will complete asynchronously.
    Started = 3,
    /// Operation is blocked (eg: by circuit breaker).
    Blocked = 4,
}
impl PendingNexusOperationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED",
            Self::Scheduled => "PENDING_NEXUS_OPERATION_STATE_SCHEDULED",
            Self::BackingOff => "PENDING_NEXUS_OPERATION_STATE_BACKING_OFF",
            Self::Started => "PENDING_NEXUS_OPERATION_STATE_STARTED",
            Self::Blocked => "PENDING_NEXUS_OPERATION_STATE_BLOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "PENDING_NEXUS_OPERATION_STATE_SCHEDULED" => Some(Self::Scheduled),
            "PENDING_NEXUS_OPERATION_STATE_BACKING_OFF" => Some(Self::BackingOff),
            "PENDING_NEXUS_OPERATION_STATE_STARTED" => Some(Self::Started),
            "PENDING_NEXUS_OPERATION_STATE_BLOCKED" => Some(Self::Blocked),
            _ => None,
        }
    }
}
/// State of a Nexus operation cancellation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NexusOperationCancellationState {
    /// Default value, unspecified state.
    Unspecified = 0,
    /// Cancellation request is in the queue waiting to be executed or is currently executing.
    Scheduled = 1,
    /// Cancellation request has failed with a retryable error and is backing off before the next attempt.
    BackingOff = 2,
    /// Cancellation request succeeded.
    Succeeded = 3,
    /// Cancellation request failed with a non-retryable error.
    Failed = 4,
    /// The associated operation timed out - exceeded the user supplied schedule-to-close timeout.
    TimedOut = 5,
    /// Cancellation request is blocked (eg: by circuit breaker).
    Blocked = 6,
}
impl NexusOperationCancellationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED",
            Self::Scheduled => "NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED",
            Self::BackingOff => "NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF",
            Self::Succeeded => "NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED",
            Self::Failed => "NEXUS_OPERATION_CANCELLATION_STATE_FAILED",
            Self::TimedOut => "NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT",
            Self::Blocked => "NEXUS_OPERATION_CANCELLATION_STATE_BLOCKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED" => Some(Self::Scheduled),
            "NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF" => Some(Self::BackingOff),
            "NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED" => Some(Self::Succeeded),
            "NEXUS_OPERATION_CANCELLATION_STATE_FAILED" => Some(Self::Failed),
            "NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT" => Some(Self::TimedOut),
            "NEXUS_OPERATION_CANCELLATION_STATE_BLOCKED" => Some(Self::Blocked),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowRuleActionScope {
    /// Default value, unspecified scope.
    Unspecified = 0,
    /// The action will be applied to the entire workflow.
    Workflow = 1,
    /// The action will be applied to a specific activity.
    Activity = 2,
}
impl WorkflowRuleActionScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKFLOW_RULE_ACTION_SCOPE_UNSPECIFIED",
            Self::Workflow => "WORKFLOW_RULE_ACTION_SCOPE_WORKFLOW",
            Self::Activity => "WORKFLOW_RULE_ACTION_SCOPE_ACTIVITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_RULE_ACTION_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKFLOW_RULE_ACTION_SCOPE_WORKFLOW" => Some(Self::Workflow),
            "WORKFLOW_RULE_ACTION_SCOPE_ACTIVITY" => Some(Self::Activity),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApplicationErrorCategory {
    Unspecified = 0,
    /// Expected application error with little/no severity.
    Benign = 1,
}
impl ApplicationErrorCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "APPLICATION_ERROR_CATEGORY_UNSPECIFIED",
            Self::Benign => "APPLICATION_ERROR_CATEGORY_BENIGN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "APPLICATION_ERROR_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "APPLICATION_ERROR_CATEGORY_BENIGN" => Some(Self::Benign),
            _ => None,
        }
    }
}
/// (-- api-linter: core::0216::synonyms=disabled
///      aip.dev/not-precedent: It seems we have both state and status, and status is a better fit for workers. --)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkerStatus {
    Unspecified = 0,
    Running = 1,
    ShuttingDown = 2,
    Shutdown = 3,
}
impl WorkerStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKER_STATUS_UNSPECIFIED",
            Self::Running => "WORKER_STATUS_RUNNING",
            Self::ShuttingDown => "WORKER_STATUS_SHUTTING_DOWN",
            Self::Shutdown => "WORKER_STATUS_SHUTDOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKER_STATUS_RUNNING" => Some(Self::Running),
            "WORKER_STATUS_SHUTTING_DOWN" => Some(Self::ShuttingDown),
            "WORKER_STATUS_SHUTDOWN" => Some(Self::Shutdown),
            _ => None,
        }
    }
}
/// Specify the reachability level for a deployment so users can decide if it is time to
/// decommission the deployment.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentReachability {
    /// Reachability level is not specified.
    Unspecified = 0,
    /// The deployment is reachable by new and/or open workflows. The deployment cannot be
    /// decommissioned safely.
    Reachable = 1,
    /// The deployment is not reachable by new or open workflows, but might be still needed by
    /// Queries sent to closed workflows. The deployment can be decommissioned safely if user does
    /// not query closed workflows.
    ClosedWorkflowsOnly = 2,
    /// The deployment is not reachable by any workflow because all the workflows who needed this
    /// deployment went out of retention period. The deployment can be decommissioned safely.
    Unreachable = 3,
}
impl DeploymentReachability {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DEPLOYMENT_REACHABILITY_UNSPECIFIED",
            Self::Reachable => "DEPLOYMENT_REACHABILITY_REACHABLE",
            Self::ClosedWorkflowsOnly => "DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY",
            Self::Unreachable => "DEPLOYMENT_REACHABILITY_UNREACHABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_REACHABILITY_UNSPECIFIED" => Some(Self::Unspecified),
            "DEPLOYMENT_REACHABILITY_REACHABLE" => Some(Self::Reachable),
            "DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY" => Some(Self::ClosedWorkflowsOnly),
            "DEPLOYMENT_REACHABILITY_UNREACHABLE" => Some(Self::Unreachable),
            _ => None,
        }
    }
}
/// (-- api-linter: core::0216::synonyms=disabled
///      aip.dev/not-precedent: Call this status because it is . --)
/// Specify the drainage status for a Worker Deployment Version so users can decide whether they
/// can safely decommission the version.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VersionDrainageStatus {
    /// Drainage Status is not specified.
    Unspecified = 0,
    /// The Worker Deployment Version is not used by new workflows but is still used by
    /// open pinned workflows. The version cannot be decommissioned safely.
    Draining = 1,
    /// The Worker Deployment Version is not used by new or open workflows, but might be still needed by
    /// Queries sent to closed workflows. The version can be decommissioned safely if user does
    /// not query closed workflows. If the user does query closed workflows for some time x after
    /// workflows are closed, they should decommission the version after it has been drained for that duration.
    Drained = 2,
}
impl VersionDrainageStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VERSION_DRAINAGE_STATUS_UNSPECIFIED",
            Self::Draining => "VERSION_DRAINAGE_STATUS_DRAINING",
            Self::Drained => "VERSION_DRAINAGE_STATUS_DRAINED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERSION_DRAINAGE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "VERSION_DRAINAGE_STATUS_DRAINING" => Some(Self::Draining),
            "VERSION_DRAINAGE_STATUS_DRAINED" => Some(Self::Drained),
            _ => None,
        }
    }
}
/// Versioning Mode of a worker is set by the app developer in the worker code, and specifies the
/// behavior of the system in the following related aspects:
/// - Whether or not Temporal Server considers this worker's version (Build ID) when dispatching
///    tasks to it.
/// - Whether or not the workflows processed by this worker are versioned using the worker's version.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkerVersioningMode {
    Unspecified = 0,
    /// Workers with this mode are not distinguished from each other for task routing, even if they
    /// have different Build IDs.
    /// Workflows processed by this worker will be unversioned and user needs to use Patching to keep
    /// the new code compatible with prior versions.
    /// This mode is recommended to be used along with Rolling Upgrade deployment strategies.
    /// Workers with this mode are represented by the special string `__unversioned__` in the APIs.
    Unversioned = 1,
    /// Workers with this mode are part of a Worker Deployment Version which is identified as
    /// "<deployment_name>.<build_id>". Such workers are called "versioned" as opposed to
    /// "unversioned".
    /// Each Deployment Version is distinguished from other Versions for task routing and users can
    /// configure Temporal Server to send tasks to a particular Version (see
    /// `WorkerDeploymentInfo.routing_config`). This mode is the best option for Blue/Green and
    /// Rainbow strategies (but typically not suitable for Rolling upgrades.)
    /// Workflow Versioning Behaviors are enabled in this mode: each workflow type must choose
    /// between the Pinned and AutoUpgrade behaviors. Depending on the chosen behavior, the user may
    /// or may not need to use Patching to keep the new code compatible with prior versions. (see
    /// VersioningBehavior enum.)
    Versioned = 2,
}
impl WorkerVersioningMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKER_VERSIONING_MODE_UNSPECIFIED",
            Self::Unversioned => "WORKER_VERSIONING_MODE_UNVERSIONED",
            Self::Versioned => "WORKER_VERSIONING_MODE_VERSIONED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKER_VERSIONING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKER_VERSIONING_MODE_UNVERSIONED" => Some(Self::Unversioned),
            "WORKER_VERSIONING_MODE_VERSIONED" => Some(Self::Versioned),
            _ => None,
        }
    }
}
/// (-- api-linter: core::0216::synonyms=disabled
///      aip.dev/not-precedent: Call this status because it is . --)
/// Specify the status of a Worker Deployment Version.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkerDeploymentVersionStatus {
    Unspecified = 0,
    /// The Worker Deployment Version has been created inside the Worker Deployment but is not used by any
    /// workflow executions. These Versions can still have workflows if they have an explicit Versioning Override targeting
    /// this Version. Such Versioning Override could be set at workflow start time, or at a later time via `UpdateWorkflowExecutionOptions`.
    Inactive = 1,
    /// The Worker Deployment Version is the current version of the Worker Deployment. All new workflow executions 
    /// and tasks of existing unversioned or AutoUpgrade workflows are routed to this version.
    Current = 2,
    /// The Worker Deployment Version is the ramping version of the Worker Deployment. A subset of new Pinned workflow executions are 
    /// routed to this version. Moreover, a portion of existing unversioned or AutoUpgrade workflow executions are also routed to this version.
    Ramping = 3,
    /// The Worker Deployment Version is not used by new workflows but is still used by
    /// open pinned workflows. The version cannot be decommissioned safely.
    Draining = 4,
    /// The Worker Deployment Version is not used by new or open workflows, but might be still needed by
    /// Queries sent to closed workflows. The version can be decommissioned safely if user does
    /// not query closed workflows. If the user does query closed workflows for some time x after
    /// workflows are closed, they should decommission the version after it has been drained for that duration.
    Drained = 5,
}
impl WorkerDeploymentVersionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKER_DEPLOYMENT_VERSION_STATUS_UNSPECIFIED",
            Self::Inactive => "WORKER_DEPLOYMENT_VERSION_STATUS_INACTIVE",
            Self::Current => "WORKER_DEPLOYMENT_VERSION_STATUS_CURRENT",
            Self::Ramping => "WORKER_DEPLOYMENT_VERSION_STATUS_RAMPING",
            Self::Draining => "WORKER_DEPLOYMENT_VERSION_STATUS_DRAINING",
            Self::Drained => "WORKER_DEPLOYMENT_VERSION_STATUS_DRAINED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKER_DEPLOYMENT_VERSION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKER_DEPLOYMENT_VERSION_STATUS_INACTIVE" => Some(Self::Inactive),
            "WORKER_DEPLOYMENT_VERSION_STATUS_CURRENT" => Some(Self::Current),
            "WORKER_DEPLOYMENT_VERSION_STATUS_RAMPING" => Some(Self::Ramping),
            "WORKER_DEPLOYMENT_VERSION_STATUS_DRAINING" => Some(Self::Draining),
            "WORKER_DEPLOYMENT_VERSION_STATUS_DRAINED" => Some(Self::Drained),
            _ => None,
        }
    }
}
/// Whenever this list of events is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventType {
    /// Place holder and should never appear in a Workflow execution history
    Unspecified = 0,
    /// Workflow execution has been triggered/started
    /// It contains Workflow execution inputs, as well as Workflow timeout configurations
    WorkflowExecutionStarted = 1,
    /// Workflow execution has successfully completed and contains Workflow execution results
    WorkflowExecutionCompleted = 2,
    /// Workflow execution has unsuccessfully completed and contains the Workflow execution error
    WorkflowExecutionFailed = 3,
    /// Workflow execution has timed out by the Temporal Server
    /// Usually due to the Workflow having not been completed within timeout settings
    WorkflowExecutionTimedOut = 4,
    /// Workflow Task has been scheduled and the SDK client should now be able to process any new history events
    WorkflowTaskScheduled = 5,
    /// Workflow Task has started and the SDK client has picked up the Workflow Task and is processing new history events
    WorkflowTaskStarted = 6,
    /// Workflow Task has completed
    /// The SDK client picked up the Workflow Task and processed new history events
    /// SDK client may or may not ask the Temporal Server to do additional work, such as:
    /// EVENT_TYPE_ACTIVITY_TASK_SCHEDULED
    /// EVENT_TYPE_TIMER_STARTED
    /// EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES
    /// EVENT_TYPE_MARKER_RECORDED
    /// EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED
    /// EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED
    /// EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED
    /// EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED
    /// EVENT_TYPE_WORKFLOW_EXECUTION_FAILED
    /// EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED
    /// EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW
    WorkflowTaskCompleted = 7,
    /// Workflow Task encountered a timeout
    /// Either an SDK client with a local cache was not available at the time, or it took too long for the SDK client to process the task
    WorkflowTaskTimedOut = 8,
    /// Workflow Task encountered a failure
    /// Usually this means that the Workflow was non-deterministic
    /// However, the Workflow reset functionality also uses this event
    WorkflowTaskFailed = 9,
    /// Activity Task was scheduled
    /// The SDK client should pick up this activity task and execute
    /// This event type contains activity inputs, as well as activity timeout configurations
    ActivityTaskScheduled = 10,
    /// Activity Task has started executing
    /// The SDK client has picked up the Activity Task and is processing the Activity invocation
    ActivityTaskStarted = 11,
    /// Activity Task has finished successfully
    /// The SDK client has picked up and successfully completed the Activity Task
    /// This event type contains Activity execution results
    ActivityTaskCompleted = 12,
    /// Activity Task has finished unsuccessfully
    /// The SDK picked up the Activity Task but unsuccessfully completed it
    /// This event type contains Activity execution errors
    ActivityTaskFailed = 13,
    /// Activity has timed out according to the Temporal Server
    /// Activity did not complete within the timeout settings
    ActivityTaskTimedOut = 14,
    /// A request to cancel the Activity has occurred
    /// The SDK client will be able to confirm cancellation of an Activity during an Activity heartbeat
    ActivityTaskCancelRequested = 15,
    /// Activity has been cancelled
    ActivityTaskCanceled = 16,
    /// A timer has started
    TimerStarted = 17,
    /// A timer has fired
    TimerFired = 18,
    /// A time has been cancelled
    TimerCanceled = 19,
    /// A request has been made to cancel the Workflow execution
    WorkflowExecutionCancelRequested = 20,
    /// SDK client has confirmed the cancellation request and the Workflow execution has been cancelled
    WorkflowExecutionCanceled = 21,
    /// Workflow has requested that the Temporal Server try to cancel another Workflow
    RequestCancelExternalWorkflowExecutionInitiated = 22,
    /// Temporal Server could not cancel the targeted Workflow
    /// This is usually because the target Workflow could not be found
    RequestCancelExternalWorkflowExecutionFailed = 23,
    /// Temporal Server has successfully requested the cancellation of the target Workflow
    ExternalWorkflowExecutionCancelRequested = 24,
    /// A marker has been recorded.
    /// This event type is transparent to the Temporal Server
    /// The Server will only store it and will not try to understand it.
    MarkerRecorded = 25,
    /// Workflow has received a Signal event
    /// The event type contains the Signal name, as well as a Signal payload
    WorkflowExecutionSignaled = 26,
    /// Workflow execution has been forcefully terminated
    /// This is usually because the terminate Workflow API was called
    WorkflowExecutionTerminated = 27,
    /// Workflow has successfully completed and a new Workflow has been started within the same transaction
    /// Contains last Workflow execution results as well as new Workflow execution inputs
    WorkflowExecutionContinuedAsNew = 28,
    /// Temporal Server will try to start a child Workflow
    StartChildWorkflowExecutionInitiated = 29,
    /// Child Workflow execution cannot be started/triggered
    /// Usually due to a child Workflow ID collision
    StartChildWorkflowExecutionFailed = 30,
    /// Child Workflow execution has successfully started/triggered
    ChildWorkflowExecutionStarted = 31,
    /// Child Workflow execution has successfully completed
    ChildWorkflowExecutionCompleted = 32,
    /// Child Workflow execution has unsuccessfully completed
    ChildWorkflowExecutionFailed = 33,
    /// Child Workflow execution has been cancelled
    ChildWorkflowExecutionCanceled = 34,
    /// Child Workflow execution has timed out by the Temporal Server
    ChildWorkflowExecutionTimedOut = 35,
    /// Child Workflow execution has been terminated
    ChildWorkflowExecutionTerminated = 36,
    /// Temporal Server will try to Signal the targeted Workflow
    /// Contains the Signal name, as well as a Signal payload
    SignalExternalWorkflowExecutionInitiated = 37,
    /// Temporal Server cannot Signal the targeted Workflow
    /// Usually because the Workflow could not be found
    SignalExternalWorkflowExecutionFailed = 38,
    /// Temporal Server has successfully Signaled the targeted Workflow
    ExternalWorkflowExecutionSignaled = 39,
    /// Workflow search attributes should be updated and synchronized with the visibility store
    UpsertWorkflowSearchAttributes = 40,
    /// An update was admitted. Note that not all admitted updates result in this
    /// event. See UpdateAdmittedEventOrigin for situations in which this event
    /// is created.
    WorkflowExecutionUpdateAdmitted = 47,
    /// An update was accepted (i.e. passed validation, perhaps because no validator was defined)
    WorkflowExecutionUpdateAccepted = 41,
    /// This event is never written to history.
    WorkflowExecutionUpdateRejected = 42,
    /// An update completed
    WorkflowExecutionUpdateCompleted = 43,
    /// Some property or properties of the workflow as a whole have changed by non-workflow code.
    /// The distinction of external vs. command-based modification is important so the SDK can
    /// maintain determinism when using the command-based approach.
    WorkflowPropertiesModifiedExternally = 44,
    /// Some property or properties of an already-scheduled activity have changed by non-workflow code.
    /// The distinction of external vs. command-based modification is important so the SDK can
    /// maintain determinism when using the command-based approach.
    ActivityPropertiesModifiedExternally = 45,
    /// Workflow properties modified by user workflow code
    WorkflowPropertiesModified = 46,
    /// A Nexus operation was scheduled using a ScheduleNexusOperation command.
    NexusOperationScheduled = 48,
    /// An asynchronous Nexus operation was started by a Nexus handler.
    NexusOperationStarted = 49,
    /// A Nexus operation completed successfully.
    NexusOperationCompleted = 50,
    /// A Nexus operation failed.
    NexusOperationFailed = 51,
    /// A Nexus operation completed as canceled.
    NexusOperationCanceled = 52,
    /// A Nexus operation timed out.
    NexusOperationTimedOut = 53,
    /// A Nexus operation was requested to be canceled using a RequestCancelNexusOperation command.
    NexusOperationCancelRequested = 54,
    /// Workflow execution options updated by user.
    WorkflowExecutionOptionsUpdated = 55,
    /// A cancellation request for a Nexus operation was successfully delivered to the Nexus handler.
    NexusOperationCancelRequestCompleted = 56,
    /// A cancellation request for a Nexus operation resulted in an error.
    NexusOperationCancelRequestFailed = 57,
}
impl EventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EVENT_TYPE_UNSPECIFIED",
            Self::WorkflowExecutionStarted => "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED",
            Self::WorkflowExecutionCompleted => "EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED",
            Self::WorkflowExecutionFailed => "EVENT_TYPE_WORKFLOW_EXECUTION_FAILED",
            Self::WorkflowExecutionTimedOut => "EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT",
            Self::WorkflowTaskScheduled => "EVENT_TYPE_WORKFLOW_TASK_SCHEDULED",
            Self::WorkflowTaskStarted => "EVENT_TYPE_WORKFLOW_TASK_STARTED",
            Self::WorkflowTaskCompleted => "EVENT_TYPE_WORKFLOW_TASK_COMPLETED",
            Self::WorkflowTaskTimedOut => "EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT",
            Self::WorkflowTaskFailed => "EVENT_TYPE_WORKFLOW_TASK_FAILED",
            Self::ActivityTaskScheduled => "EVENT_TYPE_ACTIVITY_TASK_SCHEDULED",
            Self::ActivityTaskStarted => "EVENT_TYPE_ACTIVITY_TASK_STARTED",
            Self::ActivityTaskCompleted => "EVENT_TYPE_ACTIVITY_TASK_COMPLETED",
            Self::ActivityTaskFailed => "EVENT_TYPE_ACTIVITY_TASK_FAILED",
            Self::ActivityTaskTimedOut => "EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT",
            Self::ActivityTaskCancelRequested => "EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED",
            Self::ActivityTaskCanceled => "EVENT_TYPE_ACTIVITY_TASK_CANCELED",
            Self::TimerStarted => "EVENT_TYPE_TIMER_STARTED",
            Self::TimerFired => "EVENT_TYPE_TIMER_FIRED",
            Self::TimerCanceled => "EVENT_TYPE_TIMER_CANCELED",
            Self::WorkflowExecutionCancelRequested => "EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
            Self::WorkflowExecutionCanceled => "EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED",
            Self::RequestCancelExternalWorkflowExecutionInitiated => "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
            Self::RequestCancelExternalWorkflowExecutionFailed => "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
            Self::ExternalWorkflowExecutionCancelRequested => "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
            Self::MarkerRecorded => "EVENT_TYPE_MARKER_RECORDED",
            Self::WorkflowExecutionSignaled => "EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED",
            Self::WorkflowExecutionTerminated => "EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED",
            Self::WorkflowExecutionContinuedAsNew => "EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW",
            Self::StartChildWorkflowExecutionInitiated => "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED",
            Self::StartChildWorkflowExecutionFailed => "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED",
            Self::ChildWorkflowExecutionStarted => "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED",
            Self::ChildWorkflowExecutionCompleted => "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED",
            Self::ChildWorkflowExecutionFailed => "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED",
            Self::ChildWorkflowExecutionCanceled => "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED",
            Self::ChildWorkflowExecutionTimedOut => "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT",
            Self::ChildWorkflowExecutionTerminated => "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED",
            Self::SignalExternalWorkflowExecutionInitiated => "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
            Self::SignalExternalWorkflowExecutionFailed => "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
            Self::ExternalWorkflowExecutionSignaled => "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED",
            Self::UpsertWorkflowSearchAttributes => "EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
            Self::WorkflowExecutionUpdateAdmitted => "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED",
            Self::WorkflowExecutionUpdateAccepted => "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED",
            Self::WorkflowExecutionUpdateRejected => "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED",
            Self::WorkflowExecutionUpdateCompleted => "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED",
            Self::WorkflowPropertiesModifiedExternally => "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY",
            Self::ActivityPropertiesModifiedExternally => "EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY",
            Self::WorkflowPropertiesModified => "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED",
            Self::NexusOperationScheduled => "EVENT_TYPE_NEXUS_OPERATION_SCHEDULED",
            Self::NexusOperationStarted => "EVENT_TYPE_NEXUS_OPERATION_STARTED",
            Self::NexusOperationCompleted => "EVENT_TYPE_NEXUS_OPERATION_COMPLETED",
            Self::NexusOperationFailed => "EVENT_TYPE_NEXUS_OPERATION_FAILED",
            Self::NexusOperationCanceled => "EVENT_TYPE_NEXUS_OPERATION_CANCELED",
            Self::NexusOperationTimedOut => "EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT",
            Self::NexusOperationCancelRequested => "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED",
            Self::WorkflowExecutionOptionsUpdated => "EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED",
            Self::NexusOperationCancelRequestCompleted => "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED",
            Self::NexusOperationCancelRequestFailed => "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED" => Some(Self::WorkflowExecutionStarted),
            "EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED" => Some(Self::WorkflowExecutionCompleted),
            "EVENT_TYPE_WORKFLOW_EXECUTION_FAILED" => Some(Self::WorkflowExecutionFailed),
            "EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT" => Some(Self::WorkflowExecutionTimedOut),
            "EVENT_TYPE_WORKFLOW_TASK_SCHEDULED" => Some(Self::WorkflowTaskScheduled),
            "EVENT_TYPE_WORKFLOW_TASK_STARTED" => Some(Self::WorkflowTaskStarted),
            "EVENT_TYPE_WORKFLOW_TASK_COMPLETED" => Some(Self::WorkflowTaskCompleted),
            "EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT" => Some(Self::WorkflowTaskTimedOut),
            "EVENT_TYPE_WORKFLOW_TASK_FAILED" => Some(Self::WorkflowTaskFailed),
            "EVENT_TYPE_ACTIVITY_TASK_SCHEDULED" => Some(Self::ActivityTaskScheduled),
            "EVENT_TYPE_ACTIVITY_TASK_STARTED" => Some(Self::ActivityTaskStarted),
            "EVENT_TYPE_ACTIVITY_TASK_COMPLETED" => Some(Self::ActivityTaskCompleted),
            "EVENT_TYPE_ACTIVITY_TASK_FAILED" => Some(Self::ActivityTaskFailed),
            "EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT" => Some(Self::ActivityTaskTimedOut),
            "EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED" => Some(Self::ActivityTaskCancelRequested),
            "EVENT_TYPE_ACTIVITY_TASK_CANCELED" => Some(Self::ActivityTaskCanceled),
            "EVENT_TYPE_TIMER_STARTED" => Some(Self::TimerStarted),
            "EVENT_TYPE_TIMER_FIRED" => Some(Self::TimerFired),
            "EVENT_TYPE_TIMER_CANCELED" => Some(Self::TimerCanceled),
            "EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED" => Some(Self::WorkflowExecutionCancelRequested),
            "EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED" => Some(Self::WorkflowExecutionCanceled),
            "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED" => Some(Self::RequestCancelExternalWorkflowExecutionInitiated),
            "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED" => Some(Self::RequestCancelExternalWorkflowExecutionFailed),
            "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED" => Some(Self::ExternalWorkflowExecutionCancelRequested),
            "EVENT_TYPE_MARKER_RECORDED" => Some(Self::MarkerRecorded),
            "EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED" => Some(Self::WorkflowExecutionSignaled),
            "EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED" => Some(Self::WorkflowExecutionTerminated),
            "EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW" => Some(Self::WorkflowExecutionContinuedAsNew),
            "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED" => Some(Self::StartChildWorkflowExecutionInitiated),
            "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED" => Some(Self::StartChildWorkflowExecutionFailed),
            "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED" => Some(Self::ChildWorkflowExecutionStarted),
            "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED" => Some(Self::ChildWorkflowExecutionCompleted),
            "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED" => Some(Self::ChildWorkflowExecutionFailed),
            "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED" => Some(Self::ChildWorkflowExecutionCanceled),
            "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT" => Some(Self::ChildWorkflowExecutionTimedOut),
            "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED" => Some(Self::ChildWorkflowExecutionTerminated),
            "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED" => Some(Self::SignalExternalWorkflowExecutionInitiated),
            "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED" => Some(Self::SignalExternalWorkflowExecutionFailed),
            "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED" => Some(Self::ExternalWorkflowExecutionSignaled),
            "EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES" => Some(Self::UpsertWorkflowSearchAttributes),
            "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED" => Some(Self::WorkflowExecutionUpdateAdmitted),
            "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED" => Some(Self::WorkflowExecutionUpdateAccepted),
            "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED" => Some(Self::WorkflowExecutionUpdateRejected),
            "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED" => Some(Self::WorkflowExecutionUpdateCompleted),
            "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY" => Some(Self::WorkflowPropertiesModifiedExternally),
            "EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY" => Some(Self::ActivityPropertiesModifiedExternally),
            "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED" => Some(Self::WorkflowPropertiesModified),
            "EVENT_TYPE_NEXUS_OPERATION_SCHEDULED" => Some(Self::NexusOperationScheduled),
            "EVENT_TYPE_NEXUS_OPERATION_STARTED" => Some(Self::NexusOperationStarted),
            "EVENT_TYPE_NEXUS_OPERATION_COMPLETED" => Some(Self::NexusOperationCompleted),
            "EVENT_TYPE_NEXUS_OPERATION_FAILED" => Some(Self::NexusOperationFailed),
            "EVENT_TYPE_NEXUS_OPERATION_CANCELED" => Some(Self::NexusOperationCanceled),
            "EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT" => Some(Self::NexusOperationTimedOut),
            "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED" => Some(Self::NexusOperationCancelRequested),
            "EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED" => Some(Self::WorkflowExecutionOptionsUpdated),
            "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED" => Some(Self::NexusOperationCancelRequestCompleted),
            "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED" => Some(Self::NexusOperationCancelRequestFailed),
            _ => None,
        }
    }
}
/// Workflow tasks can fail for various reasons. Note that some of these reasons can only originate
/// from the server, and some of them can only originate from the SDK/worker.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowTaskFailedCause {
    Unspecified = 0,
    /// Between starting and completing the workflow task (with a workflow completion command), some
    /// new command (like a signal) was processed into workflow history. The outstanding task will be
    /// failed with this reason, and a worker must pick up a new task.
    UnhandledCommand = 1,
    BadScheduleActivityAttributes = 2,
    BadRequestCancelActivityAttributes = 3,
    BadStartTimerAttributes = 4,
    BadCancelTimerAttributes = 5,
    BadRecordMarkerAttributes = 6,
    BadCompleteWorkflowExecutionAttributes = 7,
    BadFailWorkflowExecutionAttributes = 8,
    BadCancelWorkflowExecutionAttributes = 9,
    BadRequestCancelExternalWorkflowExecutionAttributes = 10,
    BadContinueAsNewAttributes = 11,
    StartTimerDuplicateId = 12,
    /// The worker wishes to fail the task and have the next one be generated on a normal, not sticky
    /// queue. Generally workers should prefer to use the explicit `ResetStickyTaskQueue` RPC call.
    ResetStickyTaskQueue = 13,
    WorkflowWorkerUnhandledFailure = 14,
    BadSignalWorkflowExecutionAttributes = 15,
    BadStartChildExecutionAttributes = 16,
    ForceCloseCommand = 17,
    FailoverCloseCommand = 18,
    BadSignalInputSize = 19,
    ResetWorkflow = 20,
    BadBinary = 21,
    ScheduleActivityDuplicateId = 22,
    BadSearchAttributes = 23,
    /// The worker encountered a mismatch while replaying history between what was expected, and
    /// what the workflow code actually did.
    NonDeterministicError = 24,
    BadModifyWorkflowPropertiesAttributes = 25,
    /// We send the below error codes to users when their requests would violate a size constraint
    /// of their workflow. We do this to ensure that the state of their workflow does not become too
    /// large because that can cause severe performance degradation. You can modify the thresholds for
    /// each of these errors within your dynamic config.
    ///
    /// Spawning a new child workflow would cause this workflow to exceed its limit of pending child
    /// workflows.
    PendingChildWorkflowsLimitExceeded = 26,
    /// Starting a new activity would cause this workflow to exceed its limit of pending activities
    /// that we track.
    PendingActivitiesLimitExceeded = 27,
    /// A workflow has a buffer of signals that have not yet reached their destination. We return this
    /// error when sending a new signal would exceed the capacity of this buffer.
    PendingSignalsLimitExceeded = 28,
    /// Similarly, we have a buffer of pending requests to cancel other workflows. We return this error
    /// when our capacity for pending cancel requests is already reached.
    PendingRequestCancelLimitExceeded = 29,
    /// Workflow execution update message (update.Acceptance, update.Rejection, or update.Response)
    /// has wrong format, or missing required fields.
    BadUpdateWorkflowExecutionMessage = 30,
    /// Similar to WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND, but for updates.
    UnhandledUpdate = 31,
    /// A workflow task completed with an invalid ScheduleNexusOperation command.
    BadScheduleNexusOperationAttributes = 32,
    /// A workflow task completed requesting to schedule a Nexus Operation exceeding the server configured limit.
    PendingNexusOperationsLimitExceeded = 33,
    /// A workflow task completed with an invalid RequestCancelNexusOperation command.
    BadRequestCancelNexusOperationAttributes = 34,
    /// A workflow task completed requesting a feature that's disabled on the server (either system wide or - typically -
    /// for the workflow's namespace).
    /// Check the workflow task failure message for more information.
    FeatureDisabled = 35,
    /// A workflow task failed because a grpc message was too large.
    GrpcMessageTooLarge = 36,
}
impl WorkflowTaskFailedCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED",
            Self::UnhandledCommand => "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND",
            Self::BadScheduleActivityAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES",
            Self::BadRequestCancelActivityAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES",
            Self::BadStartTimerAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES",
            Self::BadCancelTimerAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES",
            Self::BadRecordMarkerAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES",
            Self::BadCompleteWorkflowExecutionAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES",
            Self::BadFailWorkflowExecutionAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES",
            Self::BadCancelWorkflowExecutionAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES",
            Self::BadRequestCancelExternalWorkflowExecutionAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
            Self::BadContinueAsNewAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES",
            Self::StartTimerDuplicateId => "WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID",
            Self::ResetStickyTaskQueue => "WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE",
            Self::WorkflowWorkerUnhandledFailure => "WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE",
            Self::BadSignalWorkflowExecutionAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
            Self::BadStartChildExecutionAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES",
            Self::ForceCloseCommand => "WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND",
            Self::FailoverCloseCommand => "WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND",
            Self::BadSignalInputSize => "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE",
            Self::ResetWorkflow => "WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW",
            Self::BadBinary => "WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY",
            Self::ScheduleActivityDuplicateId => "WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID",
            Self::BadSearchAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES",
            Self::NonDeterministicError => "WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR",
            Self::BadModifyWorkflowPropertiesAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES",
            Self::PendingChildWorkflowsLimitExceeded => "WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED",
            Self::PendingActivitiesLimitExceeded => "WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED",
            Self::PendingSignalsLimitExceeded => "WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED",
            Self::PendingRequestCancelLimitExceeded => "WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED",
            Self::BadUpdateWorkflowExecutionMessage => "WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE",
            Self::UnhandledUpdate => "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE",
            Self::BadScheduleNexusOperationAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES",
            Self::PendingNexusOperationsLimitExceeded => "WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED",
            Self::BadRequestCancelNexusOperationAttributes => "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES",
            Self::FeatureDisabled => "WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED",
            Self::GrpcMessageTooLarge => "WORKFLOW_TASK_FAILED_CAUSE_GRPC_MESSAGE_TOO_LARGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND" => Some(Self::UnhandledCommand),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES" => Some(Self::BadScheduleActivityAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES" => Some(Self::BadRequestCancelActivityAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES" => Some(Self::BadStartTimerAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES" => Some(Self::BadCancelTimerAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES" => Some(Self::BadRecordMarkerAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES" => Some(Self::BadCompleteWorkflowExecutionAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES" => Some(Self::BadFailWorkflowExecutionAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES" => Some(Self::BadCancelWorkflowExecutionAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES" => Some(Self::BadRequestCancelExternalWorkflowExecutionAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES" => Some(Self::BadContinueAsNewAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID" => Some(Self::StartTimerDuplicateId),
            "WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE" => Some(Self::ResetStickyTaskQueue),
            "WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE" => Some(Self::WorkflowWorkerUnhandledFailure),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES" => Some(Self::BadSignalWorkflowExecutionAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES" => Some(Self::BadStartChildExecutionAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND" => Some(Self::ForceCloseCommand),
            "WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND" => Some(Self::FailoverCloseCommand),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE" => Some(Self::BadSignalInputSize),
            "WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW" => Some(Self::ResetWorkflow),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY" => Some(Self::BadBinary),
            "WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID" => Some(Self::ScheduleActivityDuplicateId),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES" => Some(Self::BadSearchAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR" => Some(Self::NonDeterministicError),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES" => Some(Self::BadModifyWorkflowPropertiesAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED" => Some(Self::PendingChildWorkflowsLimitExceeded),
            "WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED" => Some(Self::PendingActivitiesLimitExceeded),
            "WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED" => Some(Self::PendingSignalsLimitExceeded),
            "WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED" => Some(Self::PendingRequestCancelLimitExceeded),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE" => Some(Self::BadUpdateWorkflowExecutionMessage),
            "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE" => Some(Self::UnhandledUpdate),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES" => Some(Self::BadScheduleNexusOperationAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED" => Some(Self::PendingNexusOperationsLimitExceeded),
            "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES" => Some(Self::BadRequestCancelNexusOperationAttributes),
            "WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED" => Some(Self::FeatureDisabled),
            "WORKFLOW_TASK_FAILED_CAUSE_GRPC_MESSAGE_TOO_LARGE" => Some(Self::GrpcMessageTooLarge),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StartChildWorkflowExecutionFailedCause {
    Unspecified = 0,
    WorkflowAlreadyExists = 1,
    NamespaceNotFound = 2,
}
impl StartChildWorkflowExecutionFailedCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
            Self::WorkflowAlreadyExists => "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS",
            Self::NamespaceNotFound => "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
            "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS" => Some(Self::WorkflowAlreadyExists),
            "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND" => Some(Self::NamespaceNotFound),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CancelExternalWorkflowExecutionFailedCause {
    Unspecified = 0,
    ExternalWorkflowExecutionNotFound = 1,
    NamespaceNotFound = 2,
}
impl CancelExternalWorkflowExecutionFailedCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
            Self::ExternalWorkflowExecutionNotFound => "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
            Self::NamespaceNotFound => "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
            "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND" => Some(Self::ExternalWorkflowExecutionNotFound),
            "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND" => Some(Self::NamespaceNotFound),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignalExternalWorkflowExecutionFailedCause {
    Unspecified = 0,
    ExternalWorkflowExecutionNotFound = 1,
    NamespaceNotFound = 2,
    /// Signal count limit is per workflow and controlled by server dynamic config "history.maximumSignalsPerExecution"
    SignalCountLimitExceeded = 3,
}
impl SignalExternalWorkflowExecutionFailedCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
            Self::ExternalWorkflowExecutionNotFound => "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
            Self::NamespaceNotFound => "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND",
            Self::SignalCountLimitExceeded => "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
            "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND" => Some(Self::ExternalWorkflowExecutionNotFound),
            "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND" => Some(Self::NamespaceNotFound),
            "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED" => Some(Self::SignalCountLimitExceeded),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceExhaustedCause {
    Unspecified = 0,
    /// Caller exceeds request per second limit.
    RpsLimit = 1,
    /// Caller exceeds max concurrent request limit.
    ConcurrentLimit = 2,
    /// System overloaded.
    SystemOverloaded = 3,
    /// Namespace exceeds persistence rate limit.
    PersistenceLimit = 4,
    /// Workflow is busy
    BusyWorkflow = 5,
    /// Caller exceeds action per second limit.
    ApsLimit = 6,
    /// Persistence storage limit exceeded.
    PersistenceStorageLimit = 7,
    /// Circuit breaker is open/half-open.
    CircuitBreakerOpen = 8,
    /// Namespace exceeds operations rate limit.
    OpsLimit = 9,
}
impl ResourceExhaustedCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESOURCE_EXHAUSTED_CAUSE_UNSPECIFIED",
            Self::RpsLimit => "RESOURCE_EXHAUSTED_CAUSE_RPS_LIMIT",
            Self::ConcurrentLimit => "RESOURCE_EXHAUSTED_CAUSE_CONCURRENT_LIMIT",
            Self::SystemOverloaded => "RESOURCE_EXHAUSTED_CAUSE_SYSTEM_OVERLOADED",
            Self::PersistenceLimit => "RESOURCE_EXHAUSTED_CAUSE_PERSISTENCE_LIMIT",
            Self::BusyWorkflow => "RESOURCE_EXHAUSTED_CAUSE_BUSY_WORKFLOW",
            Self::ApsLimit => "RESOURCE_EXHAUSTED_CAUSE_APS_LIMIT",
            Self::PersistenceStorageLimit => "RESOURCE_EXHAUSTED_CAUSE_PERSISTENCE_STORAGE_LIMIT",
            Self::CircuitBreakerOpen => "RESOURCE_EXHAUSTED_CAUSE_CIRCUIT_BREAKER_OPEN",
            Self::OpsLimit => "RESOURCE_EXHAUSTED_CAUSE_OPS_LIMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_EXHAUSTED_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
            "RESOURCE_EXHAUSTED_CAUSE_RPS_LIMIT" => Some(Self::RpsLimit),
            "RESOURCE_EXHAUSTED_CAUSE_CONCURRENT_LIMIT" => Some(Self::ConcurrentLimit),
            "RESOURCE_EXHAUSTED_CAUSE_SYSTEM_OVERLOADED" => Some(Self::SystemOverloaded),
            "RESOURCE_EXHAUSTED_CAUSE_PERSISTENCE_LIMIT" => Some(Self::PersistenceLimit),
            "RESOURCE_EXHAUSTED_CAUSE_BUSY_WORKFLOW" => Some(Self::BusyWorkflow),
            "RESOURCE_EXHAUSTED_CAUSE_APS_LIMIT" => Some(Self::ApsLimit),
            "RESOURCE_EXHAUSTED_CAUSE_PERSISTENCE_STORAGE_LIMIT" => Some(Self::PersistenceStorageLimit),
            "RESOURCE_EXHAUSTED_CAUSE_CIRCUIT_BREAKER_OPEN" => Some(Self::CircuitBreakerOpen),
            "RESOURCE_EXHAUSTED_CAUSE_OPS_LIMIT" => Some(Self::OpsLimit),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceExhaustedScope {
    Unspecified = 0,
    /// Exhausted resource is a system-level resource.
    Namespace = 1,
    /// Exhausted resource is a namespace-level resource.
    System = 2,
}
impl ResourceExhaustedScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESOURCE_EXHAUSTED_SCOPE_UNSPECIFIED",
            Self::Namespace => "RESOURCE_EXHAUSTED_SCOPE_NAMESPACE",
            Self::System => "RESOURCE_EXHAUSTED_SCOPE_SYSTEM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_EXHAUSTED_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RESOURCE_EXHAUSTED_SCOPE_NAMESPACE" => Some(Self::Namespace),
            "RESOURCE_EXHAUSTED_SCOPE_SYSTEM" => Some(Self::System),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NamespaceState {
    Unspecified = 0,
    Registered = 1,
    Deprecated = 2,
    Deleted = 3,
}
impl NamespaceState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NAMESPACE_STATE_UNSPECIFIED",
            Self::Registered => "NAMESPACE_STATE_REGISTERED",
            Self::Deprecated => "NAMESPACE_STATE_DEPRECATED",
            Self::Deleted => "NAMESPACE_STATE_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NAMESPACE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "NAMESPACE_STATE_REGISTERED" => Some(Self::Registered),
            "NAMESPACE_STATE_DEPRECATED" => Some(Self::Deprecated),
            "NAMESPACE_STATE_DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ArchivalState {
    Unspecified = 0,
    Disabled = 1,
    Enabled = 2,
}
impl ArchivalState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ARCHIVAL_STATE_UNSPECIFIED",
            Self::Disabled => "ARCHIVAL_STATE_DISABLED",
            Self::Enabled => "ARCHIVAL_STATE_ENABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ARCHIVAL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ARCHIVAL_STATE_DISABLED" => Some(Self::Disabled),
            "ARCHIVAL_STATE_ENABLED" => Some(Self::Enabled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplicationState {
    Unspecified = 0,
    Normal = 1,
    Handover = 2,
}
impl ReplicationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REPLICATION_STATE_UNSPECIFIED",
            Self::Normal => "REPLICATION_STATE_NORMAL",
            Self::Handover => "REPLICATION_STATE_HANDOVER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLICATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "REPLICATION_STATE_NORMAL" => Some(Self::Normal),
            "REPLICATION_STATE_HANDOVER" => Some(Self::Handover),
            _ => None,
        }
    }
}
/// NexusHandlerErrorRetryBehavior allows nexus handlers to explicity set the retry behavior of a HandlerError. If not
/// specified, retry behavior is determined from the error type. For example internal errors are not retryable by default
/// unless specified otherwise.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NexusHandlerErrorRetryBehavior {
    Unspecified = 0,
    /// A handler error is explicitly marked as retryable.
    Retryable = 1,
    /// A handler error is explicitly marked as non-retryable.
    NonRetryable = 2,
}
impl NexusHandlerErrorRetryBehavior {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_UNSPECIFIED",
            Self::Retryable => "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_RETRYABLE",
            Self::NonRetryable => "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_NON_RETRYABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_UNSPECIFIED" => Some(Self::Unspecified),
            "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_RETRYABLE" => Some(Self::Retryable),
            "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_NON_RETRYABLE" => Some(Self::NonRetryable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryResultType {
    Unspecified = 0,
    Answered = 1,
    Failed = 2,
}
impl QueryResultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "QUERY_RESULT_TYPE_UNSPECIFIED",
            Self::Answered => "QUERY_RESULT_TYPE_ANSWERED",
            Self::Failed => "QUERY_RESULT_TYPE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUERY_RESULT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "QUERY_RESULT_TYPE_ANSWERED" => Some(Self::Answered),
            "QUERY_RESULT_TYPE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryRejectCondition {
    Unspecified = 0,
    /// None indicates that query should not be rejected.
    None = 1,
    /// NotOpen indicates that query should be rejected if workflow is not open.
    NotOpen = 2,
    /// NotCompletedCleanly indicates that query should be rejected if workflow did not complete cleanly.
    NotCompletedCleanly = 3,
}
impl QueryRejectCondition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "QUERY_REJECT_CONDITION_UNSPECIFIED",
            Self::None => "QUERY_REJECT_CONDITION_NONE",
            Self::NotOpen => "QUERY_REJECT_CONDITION_NOT_OPEN",
            Self::NotCompletedCleanly => "QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUERY_REJECT_CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
            "QUERY_REJECT_CONDITION_NONE" => Some(Self::None),
            "QUERY_REJECT_CONDITION_NOT_OPEN" => Some(Self::NotOpen),
            "QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY" => Some(Self::NotCompletedCleanly),
            _ => None,
        }
    }
}
/// Event types to exclude when reapplying events beyond the reset point.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResetReapplyExcludeType {
    Unspecified = 0,
    /// Exclude signals when reapplying events beyond the reset point.
    Signal = 1,
    /// Exclude updates when reapplying events beyond the reset point.
    Update = 2,
    /// Exclude nexus events when reapplying events beyond the reset point.
    Nexus = 3,
    /// Deprecated, unimplemented option.
    CancelRequest = 4,
}
impl ResetReapplyExcludeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED",
            Self::Signal => "RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL",
            Self::Update => "RESET_REAPPLY_EXCLUDE_TYPE_UPDATE",
            Self::Nexus => "RESET_REAPPLY_EXCLUDE_TYPE_NEXUS",
            Self::CancelRequest => "RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL" => Some(Self::Signal),
            "RESET_REAPPLY_EXCLUDE_TYPE_UPDATE" => Some(Self::Update),
            "RESET_REAPPLY_EXCLUDE_TYPE_NEXUS" => Some(Self::Nexus),
            "RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST" => Some(Self::CancelRequest),
            _ => None,
        }
    }
}
/// Deprecated: applications should use ResetReapplyExcludeType to specify
/// exclusions from this set, and new event types should be added to ResetReapplyExcludeType
/// instead of here.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResetReapplyType {
    Unspecified = 0,
    /// Signals are reapplied when workflow is reset.
    Signal = 1,
    /// No events are reapplied when workflow is reset.
    None = 2,
    /// All eligible events are reapplied when workflow is reset.
    AllEligible = 3,
}
impl ResetReapplyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESET_REAPPLY_TYPE_UNSPECIFIED",
            Self::Signal => "RESET_REAPPLY_TYPE_SIGNAL",
            Self::None => "RESET_REAPPLY_TYPE_NONE",
            Self::AllEligible => "RESET_REAPPLY_TYPE_ALL_ELIGIBLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESET_REAPPLY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RESET_REAPPLY_TYPE_SIGNAL" => Some(Self::Signal),
            "RESET_REAPPLY_TYPE_NONE" => Some(Self::None),
            "RESET_REAPPLY_TYPE_ALL_ELIGIBLE" => Some(Self::AllEligible),
            _ => None,
        }
    }
}
/// Deprecated, see temporal.api.common.v1.ResetOptions.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResetType {
    Unspecified = 0,
    /// Resets to event of the first workflow task completed, or if it does not exist, the event after task scheduled.
    FirstWorkflowTask = 1,
    /// Resets to event of the last workflow task completed, or if it does not exist, the event after task scheduled.
    LastWorkflowTask = 2,
}
impl ResetType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESET_TYPE_UNSPECIFIED",
            Self::FirstWorkflowTask => "RESET_TYPE_FIRST_WORKFLOW_TASK",
            Self::LastWorkflowTask => "RESET_TYPE_LAST_WORKFLOW_TASK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESET_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RESET_TYPE_FIRST_WORKFLOW_TASK" => Some(Self::FirstWorkflowTask),
            "RESET_TYPE_LAST_WORKFLOW_TASK" => Some(Self::LastWorkflowTask),
            _ => None,
        }
    }
}
/// ScheduleOverlapPolicy controls what happens when a workflow would be started
/// by a schedule, and is already running.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ScheduleOverlapPolicy {
    Unspecified = 0,
    /// SCHEDULE_OVERLAP_POLICY_SKIP (default) means don't start anything. When the
    /// workflow completes, the next scheduled event after that time will be considered.
    Skip = 1,
    /// SCHEDULE_OVERLAP_POLICY_BUFFER_ONE means start the workflow again soon as the
    /// current one completes, but only buffer one start in this way. If another start is
    /// supposed to happen when the workflow is running, and one is already buffered, then
    /// only the first one will be started after the running workflow finishes.
    BufferOne = 2,
    /// SCHEDULE_OVERLAP_POLICY_BUFFER_ALL means buffer up any number of starts to all
    /// happen sequentially, immediately after the running workflow completes.
    BufferAll = 3,
    /// SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER means that if there is another workflow
    /// running, cancel it, and start the new one after the old one completes cancellation.
    CancelOther = 4,
    /// SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER means that if there is another workflow
    /// running, terminate it and start the new one immediately.
    TerminateOther = 5,
    /// SCHEDULE_OVERLAP_POLICY_ALLOW_ALL means start any number of concurrent workflows.
    /// Note that with this policy, last completion result and last failure will not be
    /// available since workflows are not sequential.
    AllowAll = 6,
}
impl ScheduleOverlapPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
            Self::Skip => "SCHEDULE_OVERLAP_POLICY_SKIP",
            Self::BufferOne => "SCHEDULE_OVERLAP_POLICY_BUFFER_ONE",
            Self::BufferAll => "SCHEDULE_OVERLAP_POLICY_BUFFER_ALL",
            Self::CancelOther => "SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER",
            Self::TerminateOther => "SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER",
            Self::AllowAll => "SCHEDULE_OVERLAP_POLICY_ALLOW_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
            "SCHEDULE_OVERLAP_POLICY_SKIP" => Some(Self::Skip),
            "SCHEDULE_OVERLAP_POLICY_BUFFER_ONE" => Some(Self::BufferOne),
            "SCHEDULE_OVERLAP_POLICY_BUFFER_ALL" => Some(Self::BufferAll),
            "SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER" => Some(Self::CancelOther),
            "SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER" => Some(Self::TerminateOther),
            "SCHEDULE_OVERLAP_POLICY_ALLOW_ALL" => Some(Self::AllowAll),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskQueueKind {
    Unspecified = 0,
    /// Tasks from a normal workflow task queue always include complete workflow history
    ///
    /// The task queue specified by the user is always a normal task queue. There can be as many
    /// workers as desired for a single normal task queue. All those workers may pick up tasks from
    /// that queue.
    Normal = 1,
    /// A sticky queue only includes new history since the last workflow task, and they are
    /// per-worker.
    ///
    /// Sticky queues are created dynamically by each worker during their start up. They only exist
    /// for the lifetime of the worker process. Tasks in a sticky task queue are only available to
    /// the worker that created the sticky queue.
    ///
    /// Sticky queues are only for workflow tasks. There are no sticky task queues for activities.
    Sticky = 2,
}
impl TaskQueueKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TASK_QUEUE_KIND_UNSPECIFIED",
            Self::Normal => "TASK_QUEUE_KIND_NORMAL",
            Self::Sticky => "TASK_QUEUE_KIND_STICKY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_QUEUE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "TASK_QUEUE_KIND_NORMAL" => Some(Self::Normal),
            "TASK_QUEUE_KIND_STICKY" => Some(Self::Sticky),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskQueueType {
    Unspecified = 0,
    /// Workflow type of task queue.
    Workflow = 1,
    /// Activity type of task queue.
    Activity = 2,
    /// Task queue type for dispatching Nexus requests.
    Nexus = 3,
}
impl TaskQueueType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TASK_QUEUE_TYPE_UNSPECIFIED",
            Self::Workflow => "TASK_QUEUE_TYPE_WORKFLOW",
            Self::Activity => "TASK_QUEUE_TYPE_ACTIVITY",
            Self::Nexus => "TASK_QUEUE_TYPE_NEXUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_QUEUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TASK_QUEUE_TYPE_WORKFLOW" => Some(Self::Workflow),
            "TASK_QUEUE_TYPE_ACTIVITY" => Some(Self::Activity),
            "TASK_QUEUE_TYPE_NEXUS" => Some(Self::Nexus),
            _ => None,
        }
    }
}
/// Specifies which category of tasks may reach a worker on a versioned task queue.
/// Used both in a reachability query and its response.
/// Deprecated.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskReachability {
    Unspecified = 0,
    /// There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.
    NewWorkflows = 1,
    /// There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers
    /// should *not* be retired.
    /// This enum value does not distinguish between open and closed workflows.
    ExistingWorkflows = 2,
    /// There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers
    /// should *not* be retired.
    OpenWorkflows = 3,
    /// There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be
    /// retired dependending on application requirements. For example, if there's no need to query closed workflows.
    ClosedWorkflows = 4,
}
impl TaskReachability {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TASK_REACHABILITY_UNSPECIFIED",
            Self::NewWorkflows => "TASK_REACHABILITY_NEW_WORKFLOWS",
            Self::ExistingWorkflows => "TASK_REACHABILITY_EXISTING_WORKFLOWS",
            Self::OpenWorkflows => "TASK_REACHABILITY_OPEN_WORKFLOWS",
            Self::ClosedWorkflows => "TASK_REACHABILITY_CLOSED_WORKFLOWS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_REACHABILITY_UNSPECIFIED" => Some(Self::Unspecified),
            "TASK_REACHABILITY_NEW_WORKFLOWS" => Some(Self::NewWorkflows),
            "TASK_REACHABILITY_EXISTING_WORKFLOWS" => Some(Self::ExistingWorkflows),
            "TASK_REACHABILITY_OPEN_WORKFLOWS" => Some(Self::OpenWorkflows),
            "TASK_REACHABILITY_CLOSED_WORKFLOWS" => Some(Self::ClosedWorkflows),
            _ => None,
        }
    }
}
/// Specifies which category of tasks may reach a versioned worker of a certain Build ID.
///
/// Task Reachability is eventually consistent; there may be a delay (up to few minutes) until it
/// converges to the most accurate value but it is designed in a way to take the more conservative
/// side until it converges. For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
///
/// Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
/// accounted for reachability as server cannot know if they'll happen as they do not use
/// assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
/// who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
/// sure to query reachability for the parent/previous workflow's Task Queue as well.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BuildIdTaskReachability {
    /// Task reachability is not reported
    Unspecified = 0,
    /// Build ID may be used by new workflows or activities (base on versioning rules), or there MAY
    /// be open workflows or backlogged activities assigned to it.
    Reachable = 1,
    /// Build ID does not have open workflows and is not reachable by new workflows,
    /// but MAY have closed workflows within the namespace retention period.
    /// Not applicable to activity-only task queues.
    ClosedWorkflowsOnly = 2,
    /// Build ID is not used for new executions, nor it has been used by any existing execution
    /// within the retention period.
    Unreachable = 3,
}
impl BuildIdTaskReachability {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BUILD_ID_TASK_REACHABILITY_UNSPECIFIED",
            Self::Reachable => "BUILD_ID_TASK_REACHABILITY_REACHABLE",
            Self::ClosedWorkflowsOnly => "BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY",
            Self::Unreachable => "BUILD_ID_TASK_REACHABILITY_UNREACHABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUILD_ID_TASK_REACHABILITY_UNSPECIFIED" => Some(Self::Unspecified),
            "BUILD_ID_TASK_REACHABILITY_REACHABLE" => Some(Self::Reachable),
            "BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY" => Some(Self::ClosedWorkflowsOnly),
            "BUILD_ID_TASK_REACHABILITY_UNREACHABLE" => Some(Self::Unreachable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DescribeTaskQueueMode {
    /// Unspecified means legacy behavior.
    Unspecified = 0,
    /// Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.
    Enhanced = 1,
}
impl DescribeTaskQueueMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
            Self::Enhanced => "DESCRIBE_TASK_QUEUE_MODE_ENHANCED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "DESCRIBE_TASK_QUEUE_MODE_ENHANCED" => Some(Self::Enhanced),
            _ => None,
        }
    }
}
/// Source for the effective rate limit.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RateLimitSource {
    Unspecified = 0,
    /// The value was set by the API.
    Api = 1,
    /// The value was set by a worker.
    Worker = 2,
    /// The value was set as the system default.
    System = 3,
}
impl RateLimitSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RATE_LIMIT_SOURCE_UNSPECIFIED",
            Self::Api => "RATE_LIMIT_SOURCE_API",
            Self::Worker => "RATE_LIMIT_SOURCE_WORKER",
            Self::System => "RATE_LIMIT_SOURCE_SYSTEM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RATE_LIMIT_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
            "RATE_LIMIT_SOURCE_API" => Some(Self::Api),
            "RATE_LIMIT_SOURCE_WORKER" => Some(Self::Worker),
            "RATE_LIMIT_SOURCE_SYSTEM" => Some(Self::System),
            _ => None,
        }
    }
}
/// UpdateWorkflowExecutionLifecycleStage is specified by clients invoking
/// Workflow Updates and used to indicate to the server how long the
/// client wishes to wait for a return value from the API. If any value other
/// than UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED is sent by the
/// client then the API will complete before the Update is finished and will
/// return a handle to the running Update so that it can later be polled for
/// completion.
/// If specified stage wasn't reached before server timeout, server returns
/// actual stage reached.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UpdateWorkflowExecutionLifecycleStage {
    /// An unspecified value for this enum.
    Unspecified = 0,
    /// The API call will not return until the Update request has been admitted
    /// by the server - it may be the case that due to a considerations like load
    /// or resource limits that an Update is made to wait before the server will
    /// indicate that it has been received and will be processed. This value
    /// does not wait for any sort of acknowledgement from a worker.
    Admitted = 1,
    /// The API call will not return until the Update has passed validation on a worker.
    Accepted = 2,
    /// The API call will not return until the Update has executed to completion
    /// on a worker and has either been rejected or returned a value or an error.
    Completed = 3,
}
impl UpdateWorkflowExecutionLifecycleStage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED",
            Self::Admitted => "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED",
            Self::Accepted => "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED",
            Self::Completed => "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED" => Some(Self::Admitted),
            "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED" => Some(Self::Accepted),
            "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED" => Some(Self::Completed),
            _ => None,
        }
    }
}
/// Records why a WorkflowExecutionUpdateAdmittedEvent was written to history.
/// Note that not all admitted Updates result in this event.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UpdateAdmittedEventOrigin {
    Unspecified = 0,
    /// The UpdateAdmitted event was created when reapplying events during reset
    /// or replication. I.e. an accepted Update on one branch of Workflow history
    /// was converted into an admitted Update on a different branch.
    Reapply = 1,
}
impl UpdateAdmittedEventOrigin {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED",
            Self::Reapply => "UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED" => Some(Self::Unspecified),
            "UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY" => Some(Self::Reapply),
            _ => None,
        }
    }
}
/// Defines whether to allow re-using a workflow id from a previously *closed* workflow.
/// If the request is denied, the server returns a `WorkflowExecutionAlreadyStartedFailure` error.
///
/// See `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowIdReusePolicy {
    Unspecified = 0,
    /// Allow starting a workflow execution using the same workflow id.
    AllowDuplicate = 1,
    /// Allow starting a workflow execution using the same workflow id, only when the last
    /// execution's final state is one of \[terminated, cancelled, timed out, failed\].
    AllowDuplicateFailedOnly = 2,
    /// Do not permit re-use of the workflow id for this workflow. Future start workflow requests
    /// could potentially change the policy, allowing re-use of the workflow id.
    RejectDuplicate = 3,
    /// This option belongs in WorkflowIdConflictPolicy but is here for backwards compatibility.
    /// If specified, it acts like ALLOW_DUPLICATE, but also the WorkflowId*Conflict*Policy on
    /// the request is treated as WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING.
    /// If no running workflow, then the behavior is the same as ALLOW_DUPLICATE.
    TerminateIfRunning = 4,
}
impl WorkflowIdReusePolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
            Self::AllowDuplicate => "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE",
            Self::AllowDuplicateFailedOnly => "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY",
            Self::RejectDuplicate => "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE",
            Self::TerminateIfRunning => "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE" => Some(Self::AllowDuplicate),
            "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY" => Some(Self::AllowDuplicateFailedOnly),
            "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE" => Some(Self::RejectDuplicate),
            "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING" => Some(Self::TerminateIfRunning),
            _ => None,
        }
    }
}
/// Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.
/// Note that it is *never* valid to have two actively running instances of the same workflow id.
///
/// See `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowIdConflictPolicy {
    Unspecified = 0,
    /// Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.
    Fail = 1,
    /// Don't start a new workflow; instead return a workflow handle for the running workflow.
    UseExisting = 2,
    /// Terminate the running workflow before starting a new one.
    TerminateExisting = 3,
}
impl WorkflowIdConflictPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED",
            Self::Fail => "WORKFLOW_ID_CONFLICT_POLICY_FAIL",
            Self::UseExisting => "WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING",
            Self::TerminateExisting => "WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKFLOW_ID_CONFLICT_POLICY_FAIL" => Some(Self::Fail),
            "WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING" => Some(Self::UseExisting),
            "WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING" => Some(Self::TerminateExisting),
            _ => None,
        }
    }
}
/// Defines how child workflows will react to their parent completing
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParentClosePolicy {
    Unspecified = 0,
    /// The child workflow will also terminate
    Terminate = 1,
    /// The child workflow will do nothing
    Abandon = 2,
    /// Cancellation will be requested of the child workflow
    RequestCancel = 3,
}
impl ParentClosePolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PARENT_CLOSE_POLICY_UNSPECIFIED",
            Self::Terminate => "PARENT_CLOSE_POLICY_TERMINATE",
            Self::Abandon => "PARENT_CLOSE_POLICY_ABANDON",
            Self::RequestCancel => "PARENT_CLOSE_POLICY_REQUEST_CANCEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARENT_CLOSE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
            "PARENT_CLOSE_POLICY_TERMINATE" => Some(Self::Terminate),
            "PARENT_CLOSE_POLICY_ABANDON" => Some(Self::Abandon),
            "PARENT_CLOSE_POLICY_REQUEST_CANCEL" => Some(Self::RequestCancel),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContinueAsNewInitiator {
    Unspecified = 0,
    /// The workflow itself requested to continue as new
    Workflow = 1,
    /// The workflow continued as new because it is retrying
    Retry = 2,
    /// The workflow continued as new because cron has triggered a new execution
    CronSchedule = 3,
}
impl ContinueAsNewInitiator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
            Self::Workflow => "CONTINUE_AS_NEW_INITIATOR_WORKFLOW",
            Self::Retry => "CONTINUE_AS_NEW_INITIATOR_RETRY",
            Self::CronSchedule => "CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED" => Some(Self::Unspecified),
            "CONTINUE_AS_NEW_INITIATOR_WORKFLOW" => Some(Self::Workflow),
            "CONTINUE_AS_NEW_INITIATOR_RETRY" => Some(Self::Retry),
            "CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE" => Some(Self::CronSchedule),
            _ => None,
        }
    }
}
/// (-- api-linter: core::0216::synonyms=disabled
///      aip.dev/not-precedent: There is WorkflowExecutionState already in another package. --)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowExecutionStatus {
    Unspecified = 0,
    /// Value 1 is hardcoded in SQL persistence.
    Running = 1,
    Completed = 2,
    Failed = 3,
    Canceled = 4,
    Terminated = 5,
    ContinuedAsNew = 6,
    TimedOut = 7,
}
impl WorkflowExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
            Self::Running => "WORKFLOW_EXECUTION_STATUS_RUNNING",
            Self::Completed => "WORKFLOW_EXECUTION_STATUS_COMPLETED",
            Self::Failed => "WORKFLOW_EXECUTION_STATUS_FAILED",
            Self::Canceled => "WORKFLOW_EXECUTION_STATUS_CANCELED",
            Self::Terminated => "WORKFLOW_EXECUTION_STATUS_TERMINATED",
            Self::ContinuedAsNew => "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW",
            Self::TimedOut => "WORKFLOW_EXECUTION_STATUS_TIMED_OUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKFLOW_EXECUTION_STATUS_RUNNING" => Some(Self::Running),
            "WORKFLOW_EXECUTION_STATUS_COMPLETED" => Some(Self::Completed),
            "WORKFLOW_EXECUTION_STATUS_FAILED" => Some(Self::Failed),
            "WORKFLOW_EXECUTION_STATUS_CANCELED" => Some(Self::Canceled),
            "WORKFLOW_EXECUTION_STATUS_TERMINATED" => Some(Self::Terminated),
            "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW" => Some(Self::ContinuedAsNew),
            "WORKFLOW_EXECUTION_STATUS_TIMED_OUT" => Some(Self::TimedOut),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PendingActivityState {
    Unspecified = 0,
    Scheduled = 1,
    Started = 2,
    CancelRequested = 3,
    /// PAUSED means activity is paused on the server, and is not running in the worker
    Paused = 4,
    /// PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server
    PauseRequested = 5,
}
impl PendingActivityState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PENDING_ACTIVITY_STATE_UNSPECIFIED",
            Self::Scheduled => "PENDING_ACTIVITY_STATE_SCHEDULED",
            Self::Started => "PENDING_ACTIVITY_STATE_STARTED",
            Self::CancelRequested => "PENDING_ACTIVITY_STATE_CANCEL_REQUESTED",
            Self::Paused => "PENDING_ACTIVITY_STATE_PAUSED",
            Self::PauseRequested => "PENDING_ACTIVITY_STATE_PAUSE_REQUESTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PENDING_ACTIVITY_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "PENDING_ACTIVITY_STATE_SCHEDULED" => Some(Self::Scheduled),
            "PENDING_ACTIVITY_STATE_STARTED" => Some(Self::Started),
            "PENDING_ACTIVITY_STATE_CANCEL_REQUESTED" => Some(Self::CancelRequested),
            "PENDING_ACTIVITY_STATE_PAUSED" => Some(Self::Paused),
            "PENDING_ACTIVITY_STATE_PAUSE_REQUESTED" => Some(Self::PauseRequested),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PendingWorkflowTaskState {
    Unspecified = 0,
    Scheduled = 1,
    Started = 2,
}
impl PendingWorkflowTaskState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED",
            Self::Scheduled => "PENDING_WORKFLOW_TASK_STATE_SCHEDULED",
            Self::Started => "PENDING_WORKFLOW_TASK_STATE_STARTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "PENDING_WORKFLOW_TASK_STATE_SCHEDULED" => Some(Self::Scheduled),
            "PENDING_WORKFLOW_TASK_STATE_STARTED" => Some(Self::Started),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HistoryEventFilterType {
    Unspecified = 0,
    AllEvent = 1,
    CloseEvent = 2,
}
impl HistoryEventFilterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
            Self::AllEvent => "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
            Self::CloseEvent => "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT" => Some(Self::AllEvent),
            "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT" => Some(Self::CloseEvent),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RetryState {
    Unspecified = 0,
    InProgress = 1,
    NonRetryableFailure = 2,
    Timeout = 3,
    MaximumAttemptsReached = 4,
    RetryPolicyNotSet = 5,
    InternalServerError = 6,
    CancelRequested = 7,
}
impl RetryState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RETRY_STATE_UNSPECIFIED",
            Self::InProgress => "RETRY_STATE_IN_PROGRESS",
            Self::NonRetryableFailure => "RETRY_STATE_NON_RETRYABLE_FAILURE",
            Self::Timeout => "RETRY_STATE_TIMEOUT",
            Self::MaximumAttemptsReached => "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
            Self::RetryPolicyNotSet => "RETRY_STATE_RETRY_POLICY_NOT_SET",
            Self::InternalServerError => "RETRY_STATE_INTERNAL_SERVER_ERROR",
            Self::CancelRequested => "RETRY_STATE_CANCEL_REQUESTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RETRY_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "RETRY_STATE_IN_PROGRESS" => Some(Self::InProgress),
            "RETRY_STATE_NON_RETRYABLE_FAILURE" => Some(Self::NonRetryableFailure),
            "RETRY_STATE_TIMEOUT" => Some(Self::Timeout),
            "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED" => Some(Self::MaximumAttemptsReached),
            "RETRY_STATE_RETRY_POLICY_NOT_SET" => Some(Self::RetryPolicyNotSet),
            "RETRY_STATE_INTERNAL_SERVER_ERROR" => Some(Self::InternalServerError),
            "RETRY_STATE_CANCEL_REQUESTED" => Some(Self::CancelRequested),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimeoutType {
    Unspecified = 0,
    StartToClose = 1,
    ScheduleToStart = 2,
    ScheduleToClose = 3,
    Heartbeat = 4,
}
impl TimeoutType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TIMEOUT_TYPE_UNSPECIFIED",
            Self::StartToClose => "TIMEOUT_TYPE_START_TO_CLOSE",
            Self::ScheduleToStart => "TIMEOUT_TYPE_SCHEDULE_TO_START",
            Self::ScheduleToClose => "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE",
            Self::Heartbeat => "TIMEOUT_TYPE_HEARTBEAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TIMEOUT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TIMEOUT_TYPE_START_TO_CLOSE" => Some(Self::StartToClose),
            "TIMEOUT_TYPE_SCHEDULE_TO_START" => Some(Self::ScheduleToStart),
            "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE" => Some(Self::ScheduleToClose),
            "TIMEOUT_TYPE_HEARTBEAT" => Some(Self::Heartbeat),
            _ => None,
        }
    }
}
/// Versioning Behavior specifies if and how a workflow execution moves between Worker Deployment
/// Versions. The Versioning Behavior of a workflow execution is typically specified by the worker
/// who completes the first task of the execution, but is also overridable manually for new and
/// existing workflows (see VersioningOverride).
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VersioningBehavior {
    /// Workflow execution does not have a Versioning Behavior and is called Unversioned. This is the
    /// legacy behavior. An Unversioned workflow's task can go to any Unversioned worker (see
    /// `WorkerVersioningMode`.)
    /// User needs to use Patching to keep the new code compatible with prior versions when dealing
    /// with Unversioned workflows.
    Unspecified = 0,
    /// Workflow will start on the Current Deployment Version of its Task Queue, and then
    /// will be pinned to that same Deployment Version until completion (the Version that
    /// this Workflow is pinned to is specified in `versioning_info.version`).
    /// This behavior eliminates most of compatibility concerns users face when changing their code.
    /// Patching is not needed when pinned workflows code change.
    /// Can be overridden explicitly via `UpdateWorkflowExecutionOptions` API to move the
    /// execution to another Deployment Version.
    /// Activities of `PINNED` workflows are sent to the same Deployment Version. Exception to this
    /// would be when the activity Task Queue workers are not present in the workflow's Deployment
    /// Version, in which case the activity will be sent to the Current Deployment Version of its own
    /// task queue.
    Pinned = 1,
    /// Workflow will automatically move to the Current Deployment Version of its Task Queue when the
    /// next workflow task is dispatched.
    /// AutoUpgrade behavior is suitable for long-running workflows as it allows them to move to the
    /// latest Deployment Version, but the user still needs to use Patching to keep the new code
    /// compatible with prior versions for changed workflow types.
    /// Activities of `AUTO_UPGRADE` workflows are sent to the Deployment Version of the workflow
    /// execution (as specified in versioning_info.version based on the last completed
    /// workflow task). Exception to this would be when the activity Task Queue workers are not
    /// present in the workflow's Deployment Version, in which case, the activity will be sent to a
    /// different Deployment Version according to the Current Deployment Version of its own task
    /// queue.
    /// Workflows stuck on a backlogged activity will still auto-upgrade if the Current Deployment
    /// Version of their Task Queue changes, without having to wait for the backlogged activity to
    /// complete on the old Version.
    AutoUpgrade = 2,
}
impl VersioningBehavior {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VERSIONING_BEHAVIOR_UNSPECIFIED",
            Self::Pinned => "VERSIONING_BEHAVIOR_PINNED",
            Self::AutoUpgrade => "VERSIONING_BEHAVIOR_AUTO_UPGRADE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERSIONING_BEHAVIOR_UNSPECIFIED" => Some(Self::Unspecified),
            "VERSIONING_BEHAVIOR_PINNED" => Some(Self::Pinned),
            "VERSIONING_BEHAVIOR_AUTO_UPGRADE" => Some(Self::AutoUpgrade),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
