// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v6.32.0
// source: kitchen_sink.proto

package kitchensink

import (
	v1 "go.temporal.io/api/common/v1"
	v11 "go.temporal.io/api/enums/v1"
	v12 "go.temporal.io/api/failure/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Used by the service to determine the fate of a child workflow
// in case its parent is closed.
type ParentClosePolicy int32

const (
	// Let's the server set the default.
	ParentClosePolicy_PARENT_CLOSE_POLICY_UNSPECIFIED ParentClosePolicy = 0
	// Terminate means terminating the child workflow.
	ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE ParentClosePolicy = 1
	// Abandon means not doing anything on the child workflow.
	ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON ParentClosePolicy = 2
	// Cancel means requesting cancellation on the child workflow.
	ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL ParentClosePolicy = 3
)

// Enum value maps for ParentClosePolicy.
var (
	ParentClosePolicy_name = map[int32]string{
		0: "PARENT_CLOSE_POLICY_UNSPECIFIED",
		1: "PARENT_CLOSE_POLICY_TERMINATE",
		2: "PARENT_CLOSE_POLICY_ABANDON",
		3: "PARENT_CLOSE_POLICY_REQUEST_CANCEL",
	}
	ParentClosePolicy_value = map[string]int32{
		"PARENT_CLOSE_POLICY_UNSPECIFIED":    0,
		"PARENT_CLOSE_POLICY_TERMINATE":      1,
		"PARENT_CLOSE_POLICY_ABANDON":        2,
		"PARENT_CLOSE_POLICY_REQUEST_CANCEL": 3,
	}
)

func (x ParentClosePolicy) Enum() *ParentClosePolicy {
	p := new(ParentClosePolicy)
	*p = x
	return p
}

func (x ParentClosePolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ParentClosePolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_kitchen_sink_proto_enumTypes[0].Descriptor()
}

func (ParentClosePolicy) Type() protoreflect.EnumType {
	return &file_kitchen_sink_proto_enumTypes[0]
}

func (x ParentClosePolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ParentClosePolicy.Descriptor instead.
func (ParentClosePolicy) EnumDescriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{0}
}

// An indication of user's intent concerning what Build ID versioning approach should be used for
// a specific command
type VersioningIntent int32

const (
	// Indicates that core should choose the most sensible default behavior for the type of
	// command, accounting for whether the command will be run on the same task queue as the current
	// worker.
	VersioningIntent_UNSPECIFIED VersioningIntent = 0
	// Indicates that the command should run on a worker with compatible version if possible. It may
	// not be possible if the target task queue does not also have knowledge of the current worker's
	// build ID.
	VersioningIntent_COMPATIBLE VersioningIntent = 1
	// Indicates that the command should run on the target task queue's current overall-default
	// build ID.
	VersioningIntent_DEFAULT VersioningIntent = 2
)

// Enum value maps for VersioningIntent.
var (
	VersioningIntent_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "COMPATIBLE",
		2: "DEFAULT",
	}
	VersioningIntent_value = map[string]int32{
		"UNSPECIFIED": 0,
		"COMPATIBLE":  1,
		"DEFAULT":     2,
	}
)

func (x VersioningIntent) Enum() *VersioningIntent {
	p := new(VersioningIntent)
	*p = x
	return p
}

func (x VersioningIntent) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VersioningIntent) Descriptor() protoreflect.EnumDescriptor {
	return file_kitchen_sink_proto_enumTypes[1].Descriptor()
}

func (VersioningIntent) Type() protoreflect.EnumType {
	return &file_kitchen_sink_proto_enumTypes[1]
}

func (x VersioningIntent) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VersioningIntent.Descriptor instead.
func (VersioningIntent) EnumDescriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{1}
}

// Controls at which point to report back to lang when a child workflow is cancelled
type ChildWorkflowCancellationType int32

const (
	// Do not request cancellation of the child workflow if already scheduled
	ChildWorkflowCancellationType_CHILD_WF_ABANDON ChildWorkflowCancellationType = 0
	// Initiate a cancellation request and immediately report cancellation to the parent.
	ChildWorkflowCancellationType_CHILD_WF_TRY_CANCEL ChildWorkflowCancellationType = 1
	// Wait for child cancellation completion.
	ChildWorkflowCancellationType_CHILD_WF_WAIT_CANCELLATION_COMPLETED ChildWorkflowCancellationType = 2
	// Request cancellation of the child and wait for confirmation that the request was received.
	ChildWorkflowCancellationType_CHILD_WF_WAIT_CANCELLATION_REQUESTED ChildWorkflowCancellationType = 3
)

// Enum value maps for ChildWorkflowCancellationType.
var (
	ChildWorkflowCancellationType_name = map[int32]string{
		0: "CHILD_WF_ABANDON",
		1: "CHILD_WF_TRY_CANCEL",
		2: "CHILD_WF_WAIT_CANCELLATION_COMPLETED",
		3: "CHILD_WF_WAIT_CANCELLATION_REQUESTED",
	}
	ChildWorkflowCancellationType_value = map[string]int32{
		"CHILD_WF_ABANDON":                     0,
		"CHILD_WF_TRY_CANCEL":                  1,
		"CHILD_WF_WAIT_CANCELLATION_COMPLETED": 2,
		"CHILD_WF_WAIT_CANCELLATION_REQUESTED": 3,
	}
)

func (x ChildWorkflowCancellationType) Enum() *ChildWorkflowCancellationType {
	p := new(ChildWorkflowCancellationType)
	*p = x
	return p
}

func (x ChildWorkflowCancellationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChildWorkflowCancellationType) Descriptor() protoreflect.EnumDescriptor {
	return file_kitchen_sink_proto_enumTypes[2].Descriptor()
}

func (ChildWorkflowCancellationType) Type() protoreflect.EnumType {
	return &file_kitchen_sink_proto_enumTypes[2]
}

func (x ChildWorkflowCancellationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChildWorkflowCancellationType.Descriptor instead.
func (ChildWorkflowCancellationType) EnumDescriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{2}
}

type ActivityCancellationType int32

const (
	// Initiate a cancellation request and immediately report cancellation to the workflow.
	ActivityCancellationType_TRY_CANCEL ActivityCancellationType = 0
	// Wait for activity cancellation completion. Note that activity must heartbeat to receive a
	// cancellation notification. This can block the cancellation for a long time if activity
	// doesn't heartbeat or chooses to ignore the cancellation request.
	ActivityCancellationType_WAIT_CANCELLATION_COMPLETED ActivityCancellationType = 1
	// Do not request cancellation of the activity and immediately report cancellation to the
	// workflow
	ActivityCancellationType_ABANDON ActivityCancellationType = 2
)

// Enum value maps for ActivityCancellationType.
var (
	ActivityCancellationType_name = map[int32]string{
		0: "TRY_CANCEL",
		1: "WAIT_CANCELLATION_COMPLETED",
		2: "ABANDON",
	}
	ActivityCancellationType_value = map[string]int32{
		"TRY_CANCEL":                  0,
		"WAIT_CANCELLATION_COMPLETED": 1,
		"ABANDON":                     2,
	}
)

func (x ActivityCancellationType) Enum() *ActivityCancellationType {
	p := new(ActivityCancellationType)
	*p = x
	return p
}

func (x ActivityCancellationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ActivityCancellationType) Descriptor() protoreflect.EnumDescriptor {
	return file_kitchen_sink_proto_enumTypes[3].Descriptor()
}

func (ActivityCancellationType) Type() protoreflect.EnumType {
	return &file_kitchen_sink_proto_enumTypes[3]
}

func (x ActivityCancellationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ActivityCancellationType.Descriptor instead.
func (ActivityCancellationType) EnumDescriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{3}
}

// The input to the test overall. A copy of this constitutes everything that is needed to reproduce
// the test.
type TestInput struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	WorkflowInput   *WorkflowInput         `protobuf:"bytes,1,opt,name=workflow_input,json=workflowInput,proto3" json:"workflow_input,omitempty"`
	ClientSequence  *ClientSequence        `protobuf:"bytes,2,opt,name=client_sequence,json=clientSequence,proto3" json:"client_sequence,omitempty"`
	WithStartAction *WithStartClientAction `protobuf:"bytes,3,opt,name=with_start_action,json=withStartAction,proto3" json:"with_start_action,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TestInput) Reset() {
	*x = TestInput{}
	mi := &file_kitchen_sink_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TestInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestInput) ProtoMessage() {}

func (x *TestInput) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TestInput.ProtoReflect.Descriptor instead.
func (*TestInput) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{0}
}

func (x *TestInput) GetWorkflowInput() *WorkflowInput {
	if x != nil {
		return x.WorkflowInput
	}
	return nil
}

func (x *TestInput) GetClientSequence() *ClientSequence {
	if x != nil {
		return x.ClientSequence
	}
	return nil
}

func (x *TestInput) GetWithStartAction() *WithStartClientAction {
	if x != nil {
		return x.WithStartAction
	}
	return nil
}

// All the client actions that will be taken over the course of this test
type ClientSequence struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ActionSets    []*ClientActionSet     `protobuf:"bytes,1,rep,name=action_sets,json=actionSets,proto3" json:"action_sets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientSequence) Reset() {
	*x = ClientSequence{}
	mi := &file_kitchen_sink_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientSequence) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientSequence) ProtoMessage() {}

func (x *ClientSequence) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientSequence.ProtoReflect.Descriptor instead.
func (*ClientSequence) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{1}
}

func (x *ClientSequence) GetActionSets() []*ClientActionSet {
	if x != nil {
		return x.ActionSets
	}
	return nil
}

// A set of client actions to execute.
type ClientActionSet struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Actions    []*ClientAction        `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	Concurrent bool                   `protobuf:"varint,2,opt,name=concurrent,proto3" json:"concurrent,omitempty"`
	// Wait the specified amount of time at the end of the action set before proceeding to the next
	// (if there is one, if not, ignored).
	WaitAtEnd *durationpb.Duration `protobuf:"bytes,3,opt,name=wait_at_end,json=waitAtEnd,proto3" json:"wait_at_end,omitempty"`
	// If set, the client should wait for the current run to end before proceeding (IE: the workflow
	// is going to continue-as-new).
	WaitForCurrentRunToFinishAtEnd bool `protobuf:"varint,4,opt,name=wait_for_current_run_to_finish_at_end,json=waitForCurrentRunToFinishAtEnd,proto3" json:"wait_for_current_run_to_finish_at_end,omitempty"`
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *ClientActionSet) Reset() {
	*x = ClientActionSet{}
	mi := &file_kitchen_sink_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientActionSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientActionSet) ProtoMessage() {}

func (x *ClientActionSet) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientActionSet.ProtoReflect.Descriptor instead.
func (*ClientActionSet) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{2}
}

func (x *ClientActionSet) GetActions() []*ClientAction {
	if x != nil {
		return x.Actions
	}
	return nil
}

func (x *ClientActionSet) GetConcurrent() bool {
	if x != nil {
		return x.Concurrent
	}
	return false
}

func (x *ClientActionSet) GetWaitAtEnd() *durationpb.Duration {
	if x != nil {
		return x.WaitAtEnd
	}
	return nil
}

func (x *ClientActionSet) GetWaitForCurrentRunToFinishAtEnd() bool {
	if x != nil {
		return x.WaitForCurrentRunToFinishAtEnd
	}
	return false
}

type WithStartClientAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*WithStartClientAction_DoSignal
	//	*WithStartClientAction_DoUpdate
	Variant       isWithStartClientAction_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WithStartClientAction) Reset() {
	*x = WithStartClientAction{}
	mi := &file_kitchen_sink_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WithStartClientAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WithStartClientAction) ProtoMessage() {}

func (x *WithStartClientAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WithStartClientAction.ProtoReflect.Descriptor instead.
func (*WithStartClientAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{3}
}

func (x *WithStartClientAction) GetVariant() isWithStartClientAction_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *WithStartClientAction) GetDoSignal() *DoSignal {
	if x != nil {
		if x, ok := x.Variant.(*WithStartClientAction_DoSignal); ok {
			return x.DoSignal
		}
	}
	return nil
}

func (x *WithStartClientAction) GetDoUpdate() *DoUpdate {
	if x != nil {
		if x, ok := x.Variant.(*WithStartClientAction_DoUpdate); ok {
			return x.DoUpdate
		}
	}
	return nil
}

type isWithStartClientAction_Variant interface {
	isWithStartClientAction_Variant()
}

type WithStartClientAction_DoSignal struct {
	DoSignal *DoSignal `protobuf:"bytes,1,opt,name=do_signal,json=doSignal,proto3,oneof"`
}

type WithStartClientAction_DoUpdate struct {
	DoUpdate *DoUpdate `protobuf:"bytes,2,opt,name=do_update,json=doUpdate,proto3,oneof"`
}

func (*WithStartClientAction_DoSignal) isWithStartClientAction_Variant() {}

func (*WithStartClientAction_DoUpdate) isWithStartClientAction_Variant() {}

type ClientAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*ClientAction_DoSignal
	//	*ClientAction_DoQuery
	//	*ClientAction_DoUpdate
	//	*ClientAction_NestedActions
	Variant       isClientAction_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientAction) Reset() {
	*x = ClientAction{}
	mi := &file_kitchen_sink_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientAction) ProtoMessage() {}

func (x *ClientAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientAction.ProtoReflect.Descriptor instead.
func (*ClientAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{4}
}

func (x *ClientAction) GetVariant() isClientAction_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *ClientAction) GetDoSignal() *DoSignal {
	if x != nil {
		if x, ok := x.Variant.(*ClientAction_DoSignal); ok {
			return x.DoSignal
		}
	}
	return nil
}

func (x *ClientAction) GetDoQuery() *DoQuery {
	if x != nil {
		if x, ok := x.Variant.(*ClientAction_DoQuery); ok {
			return x.DoQuery
		}
	}
	return nil
}

func (x *ClientAction) GetDoUpdate() *DoUpdate {
	if x != nil {
		if x, ok := x.Variant.(*ClientAction_DoUpdate); ok {
			return x.DoUpdate
		}
	}
	return nil
}

func (x *ClientAction) GetNestedActions() *ClientActionSet {
	if x != nil {
		if x, ok := x.Variant.(*ClientAction_NestedActions); ok {
			return x.NestedActions
		}
	}
	return nil
}

type isClientAction_Variant interface {
	isClientAction_Variant()
}

type ClientAction_DoSignal struct {
	DoSignal *DoSignal `protobuf:"bytes,1,opt,name=do_signal,json=doSignal,proto3,oneof"`
}

type ClientAction_DoQuery struct {
	DoQuery *DoQuery `protobuf:"bytes,2,opt,name=do_query,json=doQuery,proto3,oneof"`
}

type ClientAction_DoUpdate struct {
	DoUpdate *DoUpdate `protobuf:"bytes,3,opt,name=do_update,json=doUpdate,proto3,oneof"`
}

type ClientAction_NestedActions struct {
	NestedActions *ClientActionSet `protobuf:"bytes,4,opt,name=nested_actions,json=nestedActions,proto3,oneof"`
}

func (*ClientAction_DoSignal) isClientAction_Variant() {}

func (*ClientAction_DoQuery) isClientAction_Variant() {}

func (*ClientAction_DoUpdate) isClientAction_Variant() {}

func (*ClientAction_NestedActions) isClientAction_Variant() {}

type DoSignal struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*DoSignal_DoSignalActions_
	//	*DoSignal_Custom
	Variant isDoSignal_Variant `protobuf_oneof:"variant"`
	// If set, the Signal is a Signal-with-Start.
	WithStart     bool `protobuf:"varint,3,opt,name=with_start,json=withStart,proto3" json:"with_start,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DoSignal) Reset() {
	*x = DoSignal{}
	mi := &file_kitchen_sink_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DoSignal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DoSignal) ProtoMessage() {}

func (x *DoSignal) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DoSignal.ProtoReflect.Descriptor instead.
func (*DoSignal) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{5}
}

func (x *DoSignal) GetVariant() isDoSignal_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *DoSignal) GetDoSignalActions() *DoSignal_DoSignalActions {
	if x != nil {
		if x, ok := x.Variant.(*DoSignal_DoSignalActions_); ok {
			return x.DoSignalActions
		}
	}
	return nil
}

func (x *DoSignal) GetCustom() *HandlerInvocation {
	if x != nil {
		if x, ok := x.Variant.(*DoSignal_Custom); ok {
			return x.Custom
		}
	}
	return nil
}

func (x *DoSignal) GetWithStart() bool {
	if x != nil {
		return x.WithStart
	}
	return false
}

type isDoSignal_Variant interface {
	isDoSignal_Variant()
}

type DoSignal_DoSignalActions_ struct {
	// A signal handler must exist named `do_actions_signal` which is responsible for handling the
	// DoSignalActions message. See it's doc for details.
	DoSignalActions *DoSignal_DoSignalActions `protobuf:"bytes,1,opt,name=do_signal_actions,json=doSignalActions,proto3,oneof"`
}

type DoSignal_Custom struct {
	// Send an arbitrary signal
	Custom *HandlerInvocation `protobuf:"bytes,2,opt,name=custom,proto3,oneof"`
}

func (*DoSignal_DoSignalActions_) isDoSignal_Variant() {}

func (*DoSignal_Custom) isDoSignal_Variant() {}

type DoQuery struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*DoQuery_ReportState
	//	*DoQuery_Custom
	Variant isDoQuery_Variant `protobuf_oneof:"variant"`
	// If set, the client should expect the query to fail
	FailureExpected bool `protobuf:"varint,10,opt,name=failure_expected,json=failureExpected,proto3" json:"failure_expected,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DoQuery) Reset() {
	*x = DoQuery{}
	mi := &file_kitchen_sink_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DoQuery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DoQuery) ProtoMessage() {}

func (x *DoQuery) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DoQuery.ProtoReflect.Descriptor instead.
func (*DoQuery) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{6}
}

func (x *DoQuery) GetVariant() isDoQuery_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *DoQuery) GetReportState() *v1.Payloads {
	if x != nil {
		if x, ok := x.Variant.(*DoQuery_ReportState); ok {
			return x.ReportState
		}
	}
	return nil
}

func (x *DoQuery) GetCustom() *HandlerInvocation {
	if x != nil {
		if x, ok := x.Variant.(*DoQuery_Custom); ok {
			return x.Custom
		}
	}
	return nil
}

func (x *DoQuery) GetFailureExpected() bool {
	if x != nil {
		return x.FailureExpected
	}
	return false
}

type isDoQuery_Variant interface {
	isDoQuery_Variant()
}

type DoQuery_ReportState struct {
	// A query must exist named `report_state` which returns the `WorkflowState` message. The input
	// is pointless and only exists to allow testing of variably-sized query args.
	ReportState *v1.Payloads `protobuf:"bytes,1,opt,name=report_state,json=reportState,proto3,oneof"`
}

type DoQuery_Custom struct {
	// Send an arbitrary query
	Custom *HandlerInvocation `protobuf:"bytes,2,opt,name=custom,proto3,oneof"`
}

func (*DoQuery_ReportState) isDoQuery_Variant() {}

func (*DoQuery_Custom) isDoQuery_Variant() {}

type DoUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*DoUpdate_DoActions
	//	*DoUpdate_Custom
	Variant isDoUpdate_Variant `protobuf_oneof:"variant"`
	// If set, the Update is an Update-with-Start.
	WithStart bool `protobuf:"varint,3,opt,name=with_start,json=withStart,proto3" json:"with_start,omitempty"`
	// If set, the client should expect the update to fail
	FailureExpected bool `protobuf:"varint,10,opt,name=failure_expected,json=failureExpected,proto3" json:"failure_expected,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DoUpdate) Reset() {
	*x = DoUpdate{}
	mi := &file_kitchen_sink_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DoUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DoUpdate) ProtoMessage() {}

func (x *DoUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DoUpdate.ProtoReflect.Descriptor instead.
func (*DoUpdate) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{7}
}

func (x *DoUpdate) GetVariant() isDoUpdate_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *DoUpdate) GetDoActions() *DoActionsUpdate {
	if x != nil {
		if x, ok := x.Variant.(*DoUpdate_DoActions); ok {
			return x.DoActions
		}
	}
	return nil
}

func (x *DoUpdate) GetCustom() *HandlerInvocation {
	if x != nil {
		if x, ok := x.Variant.(*DoUpdate_Custom); ok {
			return x.Custom
		}
	}
	return nil
}

func (x *DoUpdate) GetWithStart() bool {
	if x != nil {
		return x.WithStart
	}
	return false
}

func (x *DoUpdate) GetFailureExpected() bool {
	if x != nil {
		return x.FailureExpected
	}
	return false
}

type isDoUpdate_Variant interface {
	isDoUpdate_Variant()
}

type DoUpdate_DoActions struct {
	// An update must exist named `do_actions_update` which handles the `DoActionsUpdate` message.
	// See message doc for what it should do.
	DoActions *DoActionsUpdate `protobuf:"bytes,1,opt,name=do_actions,json=doActions,proto3,oneof"`
}

type DoUpdate_Custom struct {
	// Send an arbitrary update request
	Custom *HandlerInvocation `protobuf:"bytes,2,opt,name=custom,proto3,oneof"`
}

func (*DoUpdate_DoActions) isDoUpdate_Variant() {}

func (*DoUpdate_Custom) isDoUpdate_Variant() {}

type DoActionsUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*DoActionsUpdate_DoActions
	//	*DoActionsUpdate_RejectMe
	Variant       isDoActionsUpdate_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DoActionsUpdate) Reset() {
	*x = DoActionsUpdate{}
	mi := &file_kitchen_sink_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DoActionsUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DoActionsUpdate) ProtoMessage() {}

func (x *DoActionsUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DoActionsUpdate.ProtoReflect.Descriptor instead.
func (*DoActionsUpdate) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{8}
}

func (x *DoActionsUpdate) GetVariant() isDoActionsUpdate_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *DoActionsUpdate) GetDoActions() *ActionSet {
	if x != nil {
		if x, ok := x.Variant.(*DoActionsUpdate_DoActions); ok {
			return x.DoActions
		}
	}
	return nil
}

func (x *DoActionsUpdate) GetRejectMe() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Variant.(*DoActionsUpdate_RejectMe); ok {
			return x.RejectMe
		}
	}
	return nil
}

type isDoActionsUpdate_Variant interface {
	isDoActionsUpdate_Variant()
}

type DoActionsUpdate_DoActions struct {
	// Do same thing signal handler would do when given the provided action set. The handler should
	// return the `WorkflowState` when done with all the provided actions. You may also include a
	// `ReturnErrorAction` or `ContinueAsNewAction` in the set to exit the handler in those ways.
	DoActions *ActionSet `protobuf:"bytes,1,opt,name=do_actions,json=doActions,proto3,oneof"`
}

type DoActionsUpdate_RejectMe struct {
	// The validator should reject the update
	RejectMe *emptypb.Empty `protobuf:"bytes,2,opt,name=reject_me,json=rejectMe,proto3,oneof"`
}

func (*DoActionsUpdate_DoActions) isDoActionsUpdate_Variant() {}

func (*DoActionsUpdate_RejectMe) isDoActionsUpdate_Variant() {}

type HandlerInvocation struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Args          []*v1.Payload          `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandlerInvocation) Reset() {
	*x = HandlerInvocation{}
	mi := &file_kitchen_sink_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandlerInvocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandlerInvocation) ProtoMessage() {}

func (x *HandlerInvocation) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandlerInvocation.ProtoReflect.Descriptor instead.
func (*HandlerInvocation) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{9}
}

func (x *HandlerInvocation) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *HandlerInvocation) GetArgs() []*v1.Payload {
	if x != nil {
		return x.Args
	}
	return nil
}

// Each workflow must maintain an instance of this state
type WorkflowState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Kvs           map[string]string      `protobuf:"bytes,1,rep,name=kvs,proto3" json:"kvs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowState) Reset() {
	*x = WorkflowState{}
	mi := &file_kitchen_sink_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowState) ProtoMessage() {}

func (x *WorkflowState) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowState.ProtoReflect.Descriptor instead.
func (*WorkflowState) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{10}
}

func (x *WorkflowState) GetKvs() map[string]string {
	if x != nil {
		return x.Kvs
	}
	return nil
}

type WorkflowInput struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	InitialActions []*ActionSet           `protobuf:"bytes,1,rep,name=initial_actions,json=initialActions,proto3" json:"initial_actions,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *WorkflowInput) Reset() {
	*x = WorkflowInput{}
	mi := &file_kitchen_sink_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowInput) ProtoMessage() {}

func (x *WorkflowInput) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowInput.ProtoReflect.Descriptor instead.
func (*WorkflowInput) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{11}
}

func (x *WorkflowInput) GetInitialActions() []*ActionSet {
	if x != nil {
		return x.InitialActions
	}
	return nil
}

// A set of actions to execute concurrently or sequentially. It is necessary to be able to represent
// sequential execution without multiple 1-size action sets, as that implies the receipt of a signal
// between each of those sets, which may not be desired.
//
// All actions are handled before proceeding to the next action set, unless one of those actions
// would cause the workflow to complete/fail/CAN.
type ActionSet struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Actions       []*Action              `protobuf:"bytes,1,rep,name=actions,proto3" json:"actions,omitempty"`
	Concurrent    bool                   `protobuf:"varint,2,opt,name=concurrent,proto3" json:"concurrent,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ActionSet) Reset() {
	*x = ActionSet{}
	mi := &file_kitchen_sink_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActionSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActionSet) ProtoMessage() {}

func (x *ActionSet) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActionSet.ProtoReflect.Descriptor instead.
func (*ActionSet) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{12}
}

func (x *ActionSet) GetActions() []*Action {
	if x != nil {
		return x.Actions
	}
	return nil
}

func (x *ActionSet) GetConcurrent() bool {
	if x != nil {
		return x.Concurrent
	}
	return false
}

// Schedule-related messages
type ScheduleSpec struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	CronExpressions []string               `protobuf:"bytes,1,rep,name=cron_expressions,json=cronExpressions,proto3" json:"cron_expressions,omitempty"`
	Jitter          *durationpb.Duration   `protobuf:"bytes,2,opt,name=jitter,proto3" json:"jitter,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ScheduleSpec) Reset() {
	*x = ScheduleSpec{}
	mi := &file_kitchen_sink_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleSpec) ProtoMessage() {}

func (x *ScheduleSpec) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleSpec.ProtoReflect.Descriptor instead.
func (*ScheduleSpec) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{13}
}

func (x *ScheduleSpec) GetCronExpressions() []string {
	if x != nil {
		return x.CronExpressions
	}
	return nil
}

func (x *ScheduleSpec) GetJitter() *durationpb.Duration {
	if x != nil {
		return x.Jitter
	}
	return nil
}

type ScheduleAction struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	WorkflowId               string                 `protobuf:"bytes,1,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	WorkflowType             string                 `protobuf:"bytes,2,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	TaskQueue                string                 `protobuf:"bytes,3,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	Arguments                []*v1.Payload          `protobuf:"bytes,4,rep,name=arguments,proto3" json:"arguments,omitempty"`
	WorkflowExecutionTimeout *durationpb.Duration   `protobuf:"bytes,5,opt,name=workflow_execution_timeout,json=workflowExecutionTimeout,proto3" json:"workflow_execution_timeout,omitempty"`
	WorkflowTaskTimeout      *durationpb.Duration   `protobuf:"bytes,6,opt,name=workflow_task_timeout,json=workflowTaskTimeout,proto3" json:"workflow_task_timeout,omitempty"`
	RetryPolicy              *v1.RetryPolicy        `protobuf:"bytes,7,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *ScheduleAction) Reset() {
	*x = ScheduleAction{}
	mi := &file_kitchen_sink_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleAction) ProtoMessage() {}

func (x *ScheduleAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleAction.ProtoReflect.Descriptor instead.
func (*ScheduleAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{14}
}

func (x *ScheduleAction) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *ScheduleAction) GetWorkflowType() string {
	if x != nil {
		return x.WorkflowType
	}
	return ""
}

func (x *ScheduleAction) GetTaskQueue() string {
	if x != nil {
		return x.TaskQueue
	}
	return ""
}

func (x *ScheduleAction) GetArguments() []*v1.Payload {
	if x != nil {
		return x.Arguments
	}
	return nil
}

func (x *ScheduleAction) GetWorkflowExecutionTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowExecutionTimeout
	}
	return nil
}

func (x *ScheduleAction) GetWorkflowTaskTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowTaskTimeout
	}
	return nil
}

func (x *ScheduleAction) GetRetryPolicy() *v1.RetryPolicy {
	if x != nil {
		return x.RetryPolicy
	}
	return nil
}

type SchedulePolicies struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	RemainingActions   int64                  `protobuf:"varint,1,opt,name=remaining_actions,json=remainingActions,proto3" json:"remaining_actions,omitempty"`
	TriggerImmediately bool                   `protobuf:"varint,2,opt,name=trigger_immediately,json=triggerImmediately,proto3" json:"trigger_immediately,omitempty"`
	CatchupWindow      *durationpb.Duration   `protobuf:"bytes,3,opt,name=catchup_window,json=catchupWindow,proto3" json:"catchup_window,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *SchedulePolicies) Reset() {
	*x = SchedulePolicies{}
	mi := &file_kitchen_sink_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchedulePolicies) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchedulePolicies) ProtoMessage() {}

func (x *SchedulePolicies) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchedulePolicies.ProtoReflect.Descriptor instead.
func (*SchedulePolicies) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{15}
}

func (x *SchedulePolicies) GetRemainingActions() int64 {
	if x != nil {
		return x.RemainingActions
	}
	return 0
}

func (x *SchedulePolicies) GetTriggerImmediately() bool {
	if x != nil {
		return x.TriggerImmediately
	}
	return false
}

func (x *SchedulePolicies) GetCatchupWindow() *durationpb.Duration {
	if x != nil {
		return x.CatchupWindow
	}
	return nil
}

type ScheduleBackfill struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	StartTimestamp int64                  `protobuf:"varint,1,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	EndTimestamp   int64                  `protobuf:"varint,2,opt,name=end_timestamp,json=endTimestamp,proto3" json:"end_timestamp,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ScheduleBackfill) Reset() {
	*x = ScheduleBackfill{}
	mi := &file_kitchen_sink_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScheduleBackfill) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScheduleBackfill) ProtoMessage() {}

func (x *ScheduleBackfill) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScheduleBackfill.ProtoReflect.Descriptor instead.
func (*ScheduleBackfill) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{16}
}

func (x *ScheduleBackfill) GetStartTimestamp() int64 {
	if x != nil {
		return x.StartTimestamp
	}
	return 0
}

func (x *ScheduleBackfill) GetEndTimestamp() int64 {
	if x != nil {
		return x.EndTimestamp
	}
	return 0
}

type CreateScheduleAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ScheduleId    string                 `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	Spec          *ScheduleSpec          `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	Action        *ScheduleAction        `protobuf:"bytes,3,opt,name=action,proto3" json:"action,omitempty"`
	Policies      *SchedulePolicies      `protobuf:"bytes,4,opt,name=policies,proto3" json:"policies,omitempty"`
	Backfill      []*ScheduleBackfill    `protobuf:"bytes,5,rep,name=backfill,proto3" json:"backfill,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateScheduleAction) Reset() {
	*x = CreateScheduleAction{}
	mi := &file_kitchen_sink_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateScheduleAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateScheduleAction) ProtoMessage() {}

func (x *CreateScheduleAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateScheduleAction.ProtoReflect.Descriptor instead.
func (*CreateScheduleAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{17}
}

func (x *CreateScheduleAction) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

func (x *CreateScheduleAction) GetSpec() *ScheduleSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *CreateScheduleAction) GetAction() *ScheduleAction {
	if x != nil {
		return x.Action
	}
	return nil
}

func (x *CreateScheduleAction) GetPolicies() *SchedulePolicies {
	if x != nil {
		return x.Policies
	}
	return nil
}

func (x *CreateScheduleAction) GetBackfill() []*ScheduleBackfill {
	if x != nil {
		return x.Backfill
	}
	return nil
}

type DescribeScheduleAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ScheduleId    string                 `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DescribeScheduleAction) Reset() {
	*x = DescribeScheduleAction{}
	mi := &file_kitchen_sink_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DescribeScheduleAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DescribeScheduleAction) ProtoMessage() {}

func (x *DescribeScheduleAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DescribeScheduleAction.ProtoReflect.Descriptor instead.
func (*DescribeScheduleAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{18}
}

func (x *DescribeScheduleAction) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

type UpdateScheduleAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ScheduleId    string                 `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	Spec          *ScheduleSpec          `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateScheduleAction) Reset() {
	*x = UpdateScheduleAction{}
	mi := &file_kitchen_sink_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateScheduleAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateScheduleAction) ProtoMessage() {}

func (x *UpdateScheduleAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateScheduleAction.ProtoReflect.Descriptor instead.
func (*UpdateScheduleAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{19}
}

func (x *UpdateScheduleAction) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

func (x *UpdateScheduleAction) GetSpec() *ScheduleSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

type DeleteScheduleAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ScheduleId    string                 `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteScheduleAction) Reset() {
	*x = DeleteScheduleAction{}
	mi := &file_kitchen_sink_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteScheduleAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteScheduleAction) ProtoMessage() {}

func (x *DeleteScheduleAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteScheduleAction.ProtoReflect.Descriptor instead.
func (*DeleteScheduleAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{20}
}

func (x *DeleteScheduleAction) GetScheduleId() string {
	if x != nil {
		return x.ScheduleId
	}
	return ""
}

type Action struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*Action_Timer
	//	*Action_ExecActivity
	//	*Action_ExecChildWorkflow
	//	*Action_AwaitWorkflowState
	//	*Action_SendSignal
	//	*Action_CancelWorkflow
	//	*Action_SetPatchMarker
	//	*Action_UpsertSearchAttributes
	//	*Action_UpsertMemo
	//	*Action_SetWorkflowState
	//	*Action_ReturnResult
	//	*Action_ReturnError
	//	*Action_ContinueAsNew
	//	*Action_NestedActionSet
	//	*Action_NexusOperation
	//	*Action_CreateSchedule
	//	*Action_DescribeSchedule
	//	*Action_UpdateSchedule
	//	*Action_DeleteSchedule
	Variant       isAction_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Action) Reset() {
	*x = Action{}
	mi := &file_kitchen_sink_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Action) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Action) ProtoMessage() {}

func (x *Action) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Action.ProtoReflect.Descriptor instead.
func (*Action) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{21}
}

func (x *Action) GetVariant() isAction_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *Action) GetTimer() *TimerAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_Timer); ok {
			return x.Timer
		}
	}
	return nil
}

func (x *Action) GetExecActivity() *ExecuteActivityAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_ExecActivity); ok {
			return x.ExecActivity
		}
	}
	return nil
}

func (x *Action) GetExecChildWorkflow() *ExecuteChildWorkflowAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_ExecChildWorkflow); ok {
			return x.ExecChildWorkflow
		}
	}
	return nil
}

func (x *Action) GetAwaitWorkflowState() *AwaitWorkflowState {
	if x != nil {
		if x, ok := x.Variant.(*Action_AwaitWorkflowState); ok {
			return x.AwaitWorkflowState
		}
	}
	return nil
}

func (x *Action) GetSendSignal() *SendSignalAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_SendSignal); ok {
			return x.SendSignal
		}
	}
	return nil
}

func (x *Action) GetCancelWorkflow() *CancelWorkflowAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_CancelWorkflow); ok {
			return x.CancelWorkflow
		}
	}
	return nil
}

func (x *Action) GetSetPatchMarker() *SetPatchMarkerAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_SetPatchMarker); ok {
			return x.SetPatchMarker
		}
	}
	return nil
}

func (x *Action) GetUpsertSearchAttributes() *UpsertSearchAttributesAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_UpsertSearchAttributes); ok {
			return x.UpsertSearchAttributes
		}
	}
	return nil
}

func (x *Action) GetUpsertMemo() *UpsertMemoAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_UpsertMemo); ok {
			return x.UpsertMemo
		}
	}
	return nil
}

func (x *Action) GetSetWorkflowState() *WorkflowState {
	if x != nil {
		if x, ok := x.Variant.(*Action_SetWorkflowState); ok {
			return x.SetWorkflowState
		}
	}
	return nil
}

func (x *Action) GetReturnResult() *ReturnResultAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_ReturnResult); ok {
			return x.ReturnResult
		}
	}
	return nil
}

func (x *Action) GetReturnError() *ReturnErrorAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_ReturnError); ok {
			return x.ReturnError
		}
	}
	return nil
}

func (x *Action) GetContinueAsNew() *ContinueAsNewAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_ContinueAsNew); ok {
			return x.ContinueAsNew
		}
	}
	return nil
}

func (x *Action) GetNestedActionSet() *ActionSet {
	if x != nil {
		if x, ok := x.Variant.(*Action_NestedActionSet); ok {
			return x.NestedActionSet
		}
	}
	return nil
}

func (x *Action) GetNexusOperation() *ExecuteNexusOperation {
	if x != nil {
		if x, ok := x.Variant.(*Action_NexusOperation); ok {
			return x.NexusOperation
		}
	}
	return nil
}

func (x *Action) GetCreateSchedule() *CreateScheduleAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_CreateSchedule); ok {
			return x.CreateSchedule
		}
	}
	return nil
}

func (x *Action) GetDescribeSchedule() *DescribeScheduleAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_DescribeSchedule); ok {
			return x.DescribeSchedule
		}
	}
	return nil
}

func (x *Action) GetUpdateSchedule() *UpdateScheduleAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_UpdateSchedule); ok {
			return x.UpdateSchedule
		}
	}
	return nil
}

func (x *Action) GetDeleteSchedule() *DeleteScheduleAction {
	if x != nil {
		if x, ok := x.Variant.(*Action_DeleteSchedule); ok {
			return x.DeleteSchedule
		}
	}
	return nil
}

type isAction_Variant interface {
	isAction_Variant()
}

type Action_Timer struct {
	Timer *TimerAction `protobuf:"bytes,1,opt,name=timer,proto3,oneof"`
}

type Action_ExecActivity struct {
	ExecActivity *ExecuteActivityAction `protobuf:"bytes,2,opt,name=exec_activity,json=execActivity,proto3,oneof"`
}

type Action_ExecChildWorkflow struct {
	ExecChildWorkflow *ExecuteChildWorkflowAction `protobuf:"bytes,3,opt,name=exec_child_workflow,json=execChildWorkflow,proto3,oneof"`
}

type Action_AwaitWorkflowState struct {
	AwaitWorkflowState *AwaitWorkflowState `protobuf:"bytes,4,opt,name=await_workflow_state,json=awaitWorkflowState,proto3,oneof"`
}

type Action_SendSignal struct {
	SendSignal *SendSignalAction `protobuf:"bytes,5,opt,name=send_signal,json=sendSignal,proto3,oneof"`
}

type Action_CancelWorkflow struct {
	CancelWorkflow *CancelWorkflowAction `protobuf:"bytes,6,opt,name=cancel_workflow,json=cancelWorkflow,proto3,oneof"`
}

type Action_SetPatchMarker struct {
	SetPatchMarker *SetPatchMarkerAction `protobuf:"bytes,7,opt,name=set_patch_marker,json=setPatchMarker,proto3,oneof"`
}

type Action_UpsertSearchAttributes struct {
	UpsertSearchAttributes *UpsertSearchAttributesAction `protobuf:"bytes,8,opt,name=upsert_search_attributes,json=upsertSearchAttributes,proto3,oneof"`
}

type Action_UpsertMemo struct {
	UpsertMemo *UpsertMemoAction `protobuf:"bytes,9,opt,name=upsert_memo,json=upsertMemo,proto3,oneof"`
}

type Action_SetWorkflowState struct {
	SetWorkflowState *WorkflowState `protobuf:"bytes,10,opt,name=set_workflow_state,json=setWorkflowState,proto3,oneof"`
}

type Action_ReturnResult struct {
	ReturnResult *ReturnResultAction `protobuf:"bytes,11,opt,name=return_result,json=returnResult,proto3,oneof"`
}

type Action_ReturnError struct {
	ReturnError *ReturnErrorAction `protobuf:"bytes,12,opt,name=return_error,json=returnError,proto3,oneof"`
}

type Action_ContinueAsNew struct {
	ContinueAsNew *ContinueAsNewAction `protobuf:"bytes,13,opt,name=continue_as_new,json=continueAsNew,proto3,oneof"`
}

type Action_NestedActionSet struct {
	NestedActionSet *ActionSet `protobuf:"bytes,14,opt,name=nested_action_set,json=nestedActionSet,proto3,oneof"`
}

type Action_NexusOperation struct {
	NexusOperation *ExecuteNexusOperation `protobuf:"bytes,15,opt,name=nexus_operation,json=nexusOperation,proto3,oneof"`
}

type Action_CreateSchedule struct {
	CreateSchedule *CreateScheduleAction `protobuf:"bytes,16,opt,name=create_schedule,json=createSchedule,proto3,oneof"`
}

type Action_DescribeSchedule struct {
	DescribeSchedule *DescribeScheduleAction `protobuf:"bytes,17,opt,name=describe_schedule,json=describeSchedule,proto3,oneof"`
}

type Action_UpdateSchedule struct {
	UpdateSchedule *UpdateScheduleAction `protobuf:"bytes,18,opt,name=update_schedule,json=updateSchedule,proto3,oneof"`
}

type Action_DeleteSchedule struct {
	DeleteSchedule *DeleteScheduleAction `protobuf:"bytes,19,opt,name=delete_schedule,json=deleteSchedule,proto3,oneof"`
}

func (*Action_Timer) isAction_Variant() {}

func (*Action_ExecActivity) isAction_Variant() {}

func (*Action_ExecChildWorkflow) isAction_Variant() {}

func (*Action_AwaitWorkflowState) isAction_Variant() {}

func (*Action_SendSignal) isAction_Variant() {}

func (*Action_CancelWorkflow) isAction_Variant() {}

func (*Action_SetPatchMarker) isAction_Variant() {}

func (*Action_UpsertSearchAttributes) isAction_Variant() {}

func (*Action_UpsertMemo) isAction_Variant() {}

func (*Action_SetWorkflowState) isAction_Variant() {}

func (*Action_ReturnResult) isAction_Variant() {}

func (*Action_ReturnError) isAction_Variant() {}

func (*Action_ContinueAsNew) isAction_Variant() {}

func (*Action_NestedActionSet) isAction_Variant() {}

func (*Action_NexusOperation) isAction_Variant() {}

func (*Action_CreateSchedule) isAction_Variant() {}

func (*Action_DescribeSchedule) isAction_Variant() {}

func (*Action_UpdateSchedule) isAction_Variant() {}

func (*Action_DeleteSchedule) isAction_Variant() {}

// All await commands will have this available as a field. If it is set, the command
// should be either awaited upon, cancelled, or abandoned at the specified juncture (if possible,
// not all command types will be cancellable at all stages. Is is up to the generator to produce
// valid conditions).
type AwaitableChoice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Condition:
	//
	//	*AwaitableChoice_WaitFinish
	//	*AwaitableChoice_Abandon
	//	*AwaitableChoice_CancelBeforeStarted
	//	*AwaitableChoice_CancelAfterStarted
	//	*AwaitableChoice_CancelAfterCompleted
	Condition     isAwaitableChoice_Condition `protobuf_oneof:"condition"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AwaitableChoice) Reset() {
	*x = AwaitableChoice{}
	mi := &file_kitchen_sink_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AwaitableChoice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AwaitableChoice) ProtoMessage() {}

func (x *AwaitableChoice) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AwaitableChoice.ProtoReflect.Descriptor instead.
func (*AwaitableChoice) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{22}
}

func (x *AwaitableChoice) GetCondition() isAwaitableChoice_Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *AwaitableChoice) GetWaitFinish() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Condition.(*AwaitableChoice_WaitFinish); ok {
			return x.WaitFinish
		}
	}
	return nil
}

func (x *AwaitableChoice) GetAbandon() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Condition.(*AwaitableChoice_Abandon); ok {
			return x.Abandon
		}
	}
	return nil
}

func (x *AwaitableChoice) GetCancelBeforeStarted() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Condition.(*AwaitableChoice_CancelBeforeStarted); ok {
			return x.CancelBeforeStarted
		}
	}
	return nil
}

func (x *AwaitableChoice) GetCancelAfterStarted() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Condition.(*AwaitableChoice_CancelAfterStarted); ok {
			return x.CancelAfterStarted
		}
	}
	return nil
}

func (x *AwaitableChoice) GetCancelAfterCompleted() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Condition.(*AwaitableChoice_CancelAfterCompleted); ok {
			return x.CancelAfterCompleted
		}
	}
	return nil
}

type isAwaitableChoice_Condition interface {
	isAwaitableChoice_Condition()
}

type AwaitableChoice_WaitFinish struct {
	// Wait for the command to finish. This is the default.
	WaitFinish *emptypb.Empty `protobuf:"bytes,1,opt,name=wait_finish,json=waitFinish,proto3,oneof"`
}

type AwaitableChoice_Abandon struct {
	// Call the command API but immediately move on. IE: Don't await on it at all.
	Abandon *emptypb.Empty `protobuf:"bytes,2,opt,name=abandon,proto3,oneof"`
}

type AwaitableChoice_CancelBeforeStarted struct {
	// Cancel the command before it's begun - IE: Cancel it immediately after starting it with
	// no await, within the same workflow task.
	CancelBeforeStarted *emptypb.Empty `protobuf:"bytes,3,opt,name=cancel_before_started,json=cancelBeforeStarted,proto3,oneof"`
}

type AwaitableChoice_CancelAfterStarted struct {
	// Cancel the command after it's been started. Not all SDKs will know when a command is started
	// and in those cases they should issue the cancellation in the next workflow task after
	// creating the command.
	CancelAfterStarted *emptypb.Empty `protobuf:"bytes,4,opt,name=cancel_after_started,json=cancelAfterStarted,proto3,oneof"`
}

type AwaitableChoice_CancelAfterCompleted struct {
	// Cancel the command after it's already completed.
	CancelAfterCompleted *emptypb.Empty `protobuf:"bytes,5,opt,name=cancel_after_completed,json=cancelAfterCompleted,proto3,oneof"`
}

func (*AwaitableChoice_WaitFinish) isAwaitableChoice_Condition() {}

func (*AwaitableChoice_Abandon) isAwaitableChoice_Condition() {}

func (*AwaitableChoice_CancelBeforeStarted) isAwaitableChoice_Condition() {}

func (*AwaitableChoice_CancelAfterStarted) isAwaitableChoice_Condition() {}

func (*AwaitableChoice_CancelAfterCompleted) isAwaitableChoice_Condition() {}

type TimerAction struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Milliseconds    uint64                 `protobuf:"varint,1,opt,name=milliseconds,proto3" json:"milliseconds,omitempty"`
	AwaitableChoice *AwaitableChoice       `protobuf:"bytes,2,opt,name=awaitable_choice,json=awaitableChoice,proto3" json:"awaitable_choice,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TimerAction) Reset() {
	*x = TimerAction{}
	mi := &file_kitchen_sink_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimerAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimerAction) ProtoMessage() {}

func (x *TimerAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimerAction.ProtoReflect.Descriptor instead.
func (*TimerAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{23}
}

func (x *TimerAction) GetMilliseconds() uint64 {
	if x != nil {
		return x.Milliseconds
	}
	return 0
}

func (x *TimerAction) GetAwaitableChoice() *AwaitableChoice {
	if x != nil {
		return x.AwaitableChoice
	}
	return nil
}

type ExecuteActivityAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ActivityType:
	//
	//	*ExecuteActivityAction_Generic
	//	*ExecuteActivityAction_Delay
	//	*ExecuteActivityAction_Noop
	//	*ExecuteActivityAction_Resources
	//	*ExecuteActivityAction_Payload
	//	*ExecuteActivityAction_Client
	ActivityType isExecuteActivityAction_ActivityType `protobuf_oneof:"activity_type"`
	// The name of the task queue to place this activity request in
	TaskQueue string                 `protobuf:"bytes,4,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	Headers   map[string]*v1.Payload `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Indicates how long the caller is willing to wait for an activity completion. Limits how long
	// retries will be attempted. Either this or start_to_close_timeout_seconds must be specified.
	// When not specified defaults to the workflow execution timeout.
	ScheduleToCloseTimeout *durationpb.Duration `protobuf:"bytes,6,opt,name=schedule_to_close_timeout,json=scheduleToCloseTimeout,proto3" json:"schedule_to_close_timeout,omitempty"`
	// Limits time an activity task can stay in a task queue before a worker picks it up. This
	// timeout is always non retryable as all a retry would achieve is to put it back into the same
	// queue. Defaults to schedule_to_close_timeout or workflow execution timeout if not specified.
	ScheduleToStartTimeout *durationpb.Duration `protobuf:"bytes,7,opt,name=schedule_to_start_timeout,json=scheduleToStartTimeout,proto3" json:"schedule_to_start_timeout,omitempty"`
	// Maximum time an activity is allowed to execute after a pick up by a worker. This timeout is
	// always retryable. Either this or schedule_to_close_timeout must be specified.
	StartToCloseTimeout *durationpb.Duration `protobuf:"bytes,8,opt,name=start_to_close_timeout,json=startToCloseTimeout,proto3" json:"start_to_close_timeout,omitempty"`
	// Maximum time allowed between successful worker heartbeats.
	HeartbeatTimeout *durationpb.Duration `protobuf:"bytes,9,opt,name=heartbeat_timeout,json=heartbeatTimeout,proto3" json:"heartbeat_timeout,omitempty"`
	// Activities are provided by a default retry policy controlled through the service dynamic
	// configuration. Retries are happening up to schedule_to_close_timeout. To disable retries set
	// retry_policy.maximum_attempts to 1.
	RetryPolicy *v1.RetryPolicy `protobuf:"bytes,10,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// Whether or not this activity will be a local activity
	//
	// Types that are valid to be assigned to Locality:
	//
	//	*ExecuteActivityAction_IsLocal
	//	*ExecuteActivityAction_Remote
	Locality        isExecuteActivityAction_Locality `protobuf_oneof:"locality"`
	AwaitableChoice *AwaitableChoice                 `protobuf:"bytes,13,opt,name=awaitable_choice,json=awaitableChoice,proto3" json:"awaitable_choice,omitempty"`
	Priority        *v1.Priority                     `protobuf:"bytes,15,opt,name=priority,proto3" json:"priority,omitempty"`
	// TODO: once complete, use commonpb.PriorityKey instead
	FairnessKey    string  `protobuf:"bytes,16,opt,name=fairness_key,json=fairnessKey,proto3" json:"fairness_key,omitempty"`
	FairnessWeight float32 `protobuf:"fixed32,17,opt,name=fairness_weight,json=fairnessWeight,proto3" json:"fairness_weight,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ExecuteActivityAction) Reset() {
	*x = ExecuteActivityAction{}
	mi := &file_kitchen_sink_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteActivityAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteActivityAction) ProtoMessage() {}

func (x *ExecuteActivityAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteActivityAction.ProtoReflect.Descriptor instead.
func (*ExecuteActivityAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{24}
}

func (x *ExecuteActivityAction) GetActivityType() isExecuteActivityAction_ActivityType {
	if x != nil {
		return x.ActivityType
	}
	return nil
}

func (x *ExecuteActivityAction) GetGeneric() *ExecuteActivityAction_GenericActivity {
	if x != nil {
		if x, ok := x.ActivityType.(*ExecuteActivityAction_Generic); ok {
			return x.Generic
		}
	}
	return nil
}

func (x *ExecuteActivityAction) GetDelay() *durationpb.Duration {
	if x != nil {
		if x, ok := x.ActivityType.(*ExecuteActivityAction_Delay); ok {
			return x.Delay
		}
	}
	return nil
}

func (x *ExecuteActivityAction) GetNoop() *emptypb.Empty {
	if x != nil {
		if x, ok := x.ActivityType.(*ExecuteActivityAction_Noop); ok {
			return x.Noop
		}
	}
	return nil
}

func (x *ExecuteActivityAction) GetResources() *ExecuteActivityAction_ResourcesActivity {
	if x != nil {
		if x, ok := x.ActivityType.(*ExecuteActivityAction_Resources); ok {
			return x.Resources
		}
	}
	return nil
}

func (x *ExecuteActivityAction) GetPayload() *ExecuteActivityAction_PayloadActivity {
	if x != nil {
		if x, ok := x.ActivityType.(*ExecuteActivityAction_Payload); ok {
			return x.Payload
		}
	}
	return nil
}

func (x *ExecuteActivityAction) GetClient() *ExecuteActivityAction_ClientActivity {
	if x != nil {
		if x, ok := x.ActivityType.(*ExecuteActivityAction_Client); ok {
			return x.Client
		}
	}
	return nil
}

func (x *ExecuteActivityAction) GetTaskQueue() string {
	if x != nil {
		return x.TaskQueue
	}
	return ""
}

func (x *ExecuteActivityAction) GetHeaders() map[string]*v1.Payload {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *ExecuteActivityAction) GetScheduleToCloseTimeout() *durationpb.Duration {
	if x != nil {
		return x.ScheduleToCloseTimeout
	}
	return nil
}

func (x *ExecuteActivityAction) GetScheduleToStartTimeout() *durationpb.Duration {
	if x != nil {
		return x.ScheduleToStartTimeout
	}
	return nil
}

func (x *ExecuteActivityAction) GetStartToCloseTimeout() *durationpb.Duration {
	if x != nil {
		return x.StartToCloseTimeout
	}
	return nil
}

func (x *ExecuteActivityAction) GetHeartbeatTimeout() *durationpb.Duration {
	if x != nil {
		return x.HeartbeatTimeout
	}
	return nil
}

func (x *ExecuteActivityAction) GetRetryPolicy() *v1.RetryPolicy {
	if x != nil {
		return x.RetryPolicy
	}
	return nil
}

func (x *ExecuteActivityAction) GetLocality() isExecuteActivityAction_Locality {
	if x != nil {
		return x.Locality
	}
	return nil
}

func (x *ExecuteActivityAction) GetIsLocal() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Locality.(*ExecuteActivityAction_IsLocal); ok {
			return x.IsLocal
		}
	}
	return nil
}

func (x *ExecuteActivityAction) GetRemote() *RemoteActivityOptions {
	if x != nil {
		if x, ok := x.Locality.(*ExecuteActivityAction_Remote); ok {
			return x.Remote
		}
	}
	return nil
}

func (x *ExecuteActivityAction) GetAwaitableChoice() *AwaitableChoice {
	if x != nil {
		return x.AwaitableChoice
	}
	return nil
}

func (x *ExecuteActivityAction) GetPriority() *v1.Priority {
	if x != nil {
		return x.Priority
	}
	return nil
}

func (x *ExecuteActivityAction) GetFairnessKey() string {
	if x != nil {
		return x.FairnessKey
	}
	return ""
}

func (x *ExecuteActivityAction) GetFairnessWeight() float32 {
	if x != nil {
		return x.FairnessWeight
	}
	return 0
}

type isExecuteActivityAction_ActivityType interface {
	isExecuteActivityAction_ActivityType()
}

type ExecuteActivityAction_Generic struct {
	Generic *ExecuteActivityAction_GenericActivity `protobuf:"bytes,1,opt,name=generic,proto3,oneof"`
}

type ExecuteActivityAction_Delay struct {
	// There must be an activity named `delay` which accepts some kind of duration and waits
	// for that long
	Delay *durationpb.Duration `protobuf:"bytes,2,opt,name=delay,proto3,oneof"`
}

type ExecuteActivityAction_Noop struct {
	// There must be an activity named `noop` which does nothing
	Noop *emptypb.Empty `protobuf:"bytes,3,opt,name=noop,proto3,oneof"`
}

type ExecuteActivityAction_Resources struct {
	// There must be an activity named `resources` which accepts the ResourcesActivity message as input
	Resources *ExecuteActivityAction_ResourcesActivity `protobuf:"bytes,14,opt,name=resources,proto3,oneof"`
}

type ExecuteActivityAction_Payload struct {
	// There must be an activity named `payload` which accepts the PayloadActivity message as input
	Payload *ExecuteActivityAction_PayloadActivity `protobuf:"bytes,18,opt,name=payload,proto3,oneof"`
}

type ExecuteActivityAction_Client struct {
	// There must be an activity named `client` which accepts the ClientActivity message as input
	Client *ExecuteActivityAction_ClientActivity `protobuf:"bytes,19,opt,name=client,proto3,oneof"`
}

func (*ExecuteActivityAction_Generic) isExecuteActivityAction_ActivityType() {}

func (*ExecuteActivityAction_Delay) isExecuteActivityAction_ActivityType() {}

func (*ExecuteActivityAction_Noop) isExecuteActivityAction_ActivityType() {}

func (*ExecuteActivityAction_Resources) isExecuteActivityAction_ActivityType() {}

func (*ExecuteActivityAction_Payload) isExecuteActivityAction_ActivityType() {}

func (*ExecuteActivityAction_Client) isExecuteActivityAction_ActivityType() {}

type isExecuteActivityAction_Locality interface {
	isExecuteActivityAction_Locality()
}

type ExecuteActivityAction_IsLocal struct {
	IsLocal *emptypb.Empty `protobuf:"bytes,11,opt,name=is_local,json=isLocal,proto3,oneof"`
}

type ExecuteActivityAction_Remote struct {
	Remote *RemoteActivityOptions `protobuf:"bytes,12,opt,name=remote,proto3,oneof"`
}

func (*ExecuteActivityAction_IsLocal) isExecuteActivityAction_Locality() {}

func (*ExecuteActivityAction_Remote) isExecuteActivityAction_Locality() {}

type ExecuteChildWorkflowAction struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Namespace    string                 `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	WorkflowId   string                 `protobuf:"bytes,3,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	WorkflowType string                 `protobuf:"bytes,4,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	TaskQueue    string                 `protobuf:"bytes,5,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	Input        []*v1.Payload          `protobuf:"bytes,6,rep,name=input,proto3" json:"input,omitempty"`
	// Total workflow execution timeout including retries and continue as new.
	WorkflowExecutionTimeout *durationpb.Duration `protobuf:"bytes,7,opt,name=workflow_execution_timeout,json=workflowExecutionTimeout,proto3" json:"workflow_execution_timeout,omitempty"`
	// Timeout of a single workflow run.
	WorkflowRunTimeout *durationpb.Duration `protobuf:"bytes,8,opt,name=workflow_run_timeout,json=workflowRunTimeout,proto3" json:"workflow_run_timeout,omitempty"`
	// Timeout of a single workflow task.
	WorkflowTaskTimeout *durationpb.Duration `protobuf:"bytes,9,opt,name=workflow_task_timeout,json=workflowTaskTimeout,proto3" json:"workflow_task_timeout,omitempty"`
	// Default: PARENT_CLOSE_POLICY_TERMINATE.
	ParentClosePolicy ParentClosePolicy `protobuf:"varint,10,opt,name=parent_close_policy,json=parentClosePolicy,proto3,enum=temporal.omes.kitchen_sink.ParentClosePolicy" json:"parent_close_policy,omitempty"`
	// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
	WorkflowIdReusePolicy v11.WorkflowIdReusePolicy `protobuf:"varint,12,opt,name=workflow_id_reuse_policy,json=workflowIdReusePolicy,proto3,enum=temporal.api.enums.v1.WorkflowIdReusePolicy" json:"workflow_id_reuse_policy,omitempty"`
	RetryPolicy           *v1.RetryPolicy           `protobuf:"bytes,13,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	CronSchedule          string                    `protobuf:"bytes,14,opt,name=cron_schedule,json=cronSchedule,proto3" json:"cron_schedule,omitempty"`
	// Header fields
	Headers map[string]*v1.Payload `protobuf:"bytes,15,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Memo fields
	Memo map[string]*v1.Payload `protobuf:"bytes,16,rep,name=memo,proto3" json:"memo,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Search attributes
	SearchAttributes map[string]*v1.Payload `protobuf:"bytes,17,rep,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Defines behaviour of the underlying workflow when child workflow cancellation has been requested.
	CancellationType ChildWorkflowCancellationType `protobuf:"varint,18,opt,name=cancellation_type,json=cancellationType,proto3,enum=temporal.omes.kitchen_sink.ChildWorkflowCancellationType" json:"cancellation_type,omitempty"`
	// Whether this child should run on a worker with a compatible build id or not.
	VersioningIntent VersioningIntent `protobuf:"varint,19,opt,name=versioning_intent,json=versioningIntent,proto3,enum=temporal.omes.kitchen_sink.VersioningIntent" json:"versioning_intent,omitempty"`
	AwaitableChoice  *AwaitableChoice `protobuf:"bytes,20,opt,name=awaitable_choice,json=awaitableChoice,proto3" json:"awaitable_choice,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ExecuteChildWorkflowAction) Reset() {
	*x = ExecuteChildWorkflowAction{}
	mi := &file_kitchen_sink_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteChildWorkflowAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteChildWorkflowAction) ProtoMessage() {}

func (x *ExecuteChildWorkflowAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteChildWorkflowAction.ProtoReflect.Descriptor instead.
func (*ExecuteChildWorkflowAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{25}
}

func (x *ExecuteChildWorkflowAction) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *ExecuteChildWorkflowAction) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *ExecuteChildWorkflowAction) GetWorkflowType() string {
	if x != nil {
		return x.WorkflowType
	}
	return ""
}

func (x *ExecuteChildWorkflowAction) GetTaskQueue() string {
	if x != nil {
		return x.TaskQueue
	}
	return ""
}

func (x *ExecuteChildWorkflowAction) GetInput() []*v1.Payload {
	if x != nil {
		return x.Input
	}
	return nil
}

func (x *ExecuteChildWorkflowAction) GetWorkflowExecutionTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowExecutionTimeout
	}
	return nil
}

func (x *ExecuteChildWorkflowAction) GetWorkflowRunTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowRunTimeout
	}
	return nil
}

func (x *ExecuteChildWorkflowAction) GetWorkflowTaskTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowTaskTimeout
	}
	return nil
}

func (x *ExecuteChildWorkflowAction) GetParentClosePolicy() ParentClosePolicy {
	if x != nil {
		return x.ParentClosePolicy
	}
	return ParentClosePolicy_PARENT_CLOSE_POLICY_UNSPECIFIED
}

func (x *ExecuteChildWorkflowAction) GetWorkflowIdReusePolicy() v11.WorkflowIdReusePolicy {
	if x != nil {
		return x.WorkflowIdReusePolicy
	}
	return v11.WorkflowIdReusePolicy(0)
}

func (x *ExecuteChildWorkflowAction) GetRetryPolicy() *v1.RetryPolicy {
	if x != nil {
		return x.RetryPolicy
	}
	return nil
}

func (x *ExecuteChildWorkflowAction) GetCronSchedule() string {
	if x != nil {
		return x.CronSchedule
	}
	return ""
}

func (x *ExecuteChildWorkflowAction) GetHeaders() map[string]*v1.Payload {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *ExecuteChildWorkflowAction) GetMemo() map[string]*v1.Payload {
	if x != nil {
		return x.Memo
	}
	return nil
}

func (x *ExecuteChildWorkflowAction) GetSearchAttributes() map[string]*v1.Payload {
	if x != nil {
		return x.SearchAttributes
	}
	return nil
}

func (x *ExecuteChildWorkflowAction) GetCancellationType() ChildWorkflowCancellationType {
	if x != nil {
		return x.CancellationType
	}
	return ChildWorkflowCancellationType_CHILD_WF_ABANDON
}

func (x *ExecuteChildWorkflowAction) GetVersioningIntent() VersioningIntent {
	if x != nil {
		return x.VersioningIntent
	}
	return VersioningIntent_UNSPECIFIED
}

func (x *ExecuteChildWorkflowAction) GetAwaitableChoice() *AwaitableChoice {
	if x != nil {
		return x.AwaitableChoice
	}
	return nil
}

// Wait for the workflow state to have a matching k/v entry
type AwaitWorkflowState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AwaitWorkflowState) Reset() {
	*x = AwaitWorkflowState{}
	mi := &file_kitchen_sink_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AwaitWorkflowState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AwaitWorkflowState) ProtoMessage() {}

func (x *AwaitWorkflowState) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AwaitWorkflowState.ProtoReflect.Descriptor instead.
func (*AwaitWorkflowState) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{26}
}

func (x *AwaitWorkflowState) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *AwaitWorkflowState) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type SendSignalAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// What workflow is being targeted
	WorkflowId string `protobuf:"bytes,1,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId      string `protobuf:"bytes,2,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	// Name of the signal handler
	SignalName string `protobuf:"bytes,3,opt,name=signal_name,json=signalName,proto3" json:"signal_name,omitempty"`
	// Arguments for the handler
	Args []*v1.Payload `protobuf:"bytes,4,rep,name=args,proto3" json:"args,omitempty"`
	// Headers to attach to the signal
	Headers         map[string]*v1.Payload `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	AwaitableChoice *AwaitableChoice       `protobuf:"bytes,6,opt,name=awaitable_choice,json=awaitableChoice,proto3" json:"awaitable_choice,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SendSignalAction) Reset() {
	*x = SendSignalAction{}
	mi := &file_kitchen_sink_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendSignalAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendSignalAction) ProtoMessage() {}

func (x *SendSignalAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendSignalAction.ProtoReflect.Descriptor instead.
func (*SendSignalAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{27}
}

func (x *SendSignalAction) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *SendSignalAction) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

func (x *SendSignalAction) GetSignalName() string {
	if x != nil {
		return x.SignalName
	}
	return ""
}

func (x *SendSignalAction) GetArgs() []*v1.Payload {
	if x != nil {
		return x.Args
	}
	return nil
}

func (x *SendSignalAction) GetHeaders() map[string]*v1.Payload {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *SendSignalAction) GetAwaitableChoice() *AwaitableChoice {
	if x != nil {
		return x.AwaitableChoice
	}
	return nil
}

// Cancel an external workflow (may be a child)
type CancelWorkflowAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	WorkflowId    string                 `protobuf:"bytes,1,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	RunId         string                 `protobuf:"bytes,2,opt,name=run_id,json=runId,proto3" json:"run_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CancelWorkflowAction) Reset() {
	*x = CancelWorkflowAction{}
	mi := &file_kitchen_sink_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CancelWorkflowAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelWorkflowAction) ProtoMessage() {}

func (x *CancelWorkflowAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelWorkflowAction.ProtoReflect.Descriptor instead.
func (*CancelWorkflowAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{28}
}

func (x *CancelWorkflowAction) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *CancelWorkflowAction) GetRunId() string {
	if x != nil {
		return x.RunId
	}
	return ""
}

// patched or getVersion API
// For getVersion SDKs, use `DEFAULT_VERSION, 1` as the numeric arguments,
type SetPatchMarkerAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A user-chosen identifier for this patch. If the same identifier is used in multiple places in
	// the code, those places are considered to be versioned as one unit. IE: The check call will
	// return the same result for all of them
	PatchId string `protobuf:"bytes,1,opt,name=patch_id,json=patchId,proto3" json:"patch_id,omitempty"`
	// TODO Not sure how we could use this in these tests
	// Can be set to true to indicate that branches using this change are being removed, and all
	// future worker deployments will only have the "with change" code in them.
	Deprecated bool `protobuf:"varint,2,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
	// Perform this action behind the if guard
	InnerAction   *Action `protobuf:"bytes,3,opt,name=inner_action,json=innerAction,proto3" json:"inner_action,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetPatchMarkerAction) Reset() {
	*x = SetPatchMarkerAction{}
	mi := &file_kitchen_sink_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetPatchMarkerAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetPatchMarkerAction) ProtoMessage() {}

func (x *SetPatchMarkerAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetPatchMarkerAction.ProtoReflect.Descriptor instead.
func (*SetPatchMarkerAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{29}
}

func (x *SetPatchMarkerAction) GetPatchId() string {
	if x != nil {
		return x.PatchId
	}
	return ""
}

func (x *SetPatchMarkerAction) GetDeprecated() bool {
	if x != nil {
		return x.Deprecated
	}
	return false
}

func (x *SetPatchMarkerAction) GetInnerAction() *Action {
	if x != nil {
		return x.InnerAction
	}
	return nil
}

type UpsertSearchAttributesAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SearchAttributes fields - equivalent to indexed_fields on api. Key = search index, Value =
	// value
	SearchAttributes map[string]*v1.Payload `protobuf:"bytes,1,rep,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *UpsertSearchAttributesAction) Reset() {
	*x = UpsertSearchAttributesAction{}
	mi := &file_kitchen_sink_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpsertSearchAttributesAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpsertSearchAttributesAction) ProtoMessage() {}

func (x *UpsertSearchAttributesAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpsertSearchAttributesAction.ProtoReflect.Descriptor instead.
func (*UpsertSearchAttributesAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{30}
}

func (x *UpsertSearchAttributesAction) GetSearchAttributes() map[string]*v1.Payload {
	if x != nil {
		return x.SearchAttributes
	}
	return nil
}

type UpsertMemoAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Update the workflow memo with the provided values. The values will be merged with
	// the existing memo. If the user wants to delete values, a default/empty Payload should be
	// used as the value for the key being deleted.
	UpsertedMemo  *v1.Memo `protobuf:"bytes,1,opt,name=upserted_memo,json=upsertedMemo,proto3" json:"upserted_memo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpsertMemoAction) Reset() {
	*x = UpsertMemoAction{}
	mi := &file_kitchen_sink_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpsertMemoAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpsertMemoAction) ProtoMessage() {}

func (x *UpsertMemoAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpsertMemoAction.ProtoReflect.Descriptor instead.
func (*UpsertMemoAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{31}
}

func (x *UpsertMemoAction) GetUpsertedMemo() *v1.Memo {
	if x != nil {
		return x.UpsertedMemo
	}
	return nil
}

type ReturnResultAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ReturnThis    *v1.Payload            `protobuf:"bytes,1,opt,name=return_this,json=returnThis,proto3" json:"return_this,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReturnResultAction) Reset() {
	*x = ReturnResultAction{}
	mi := &file_kitchen_sink_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReturnResultAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReturnResultAction) ProtoMessage() {}

func (x *ReturnResultAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReturnResultAction.ProtoReflect.Descriptor instead.
func (*ReturnResultAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{32}
}

func (x *ReturnResultAction) GetReturnThis() *v1.Payload {
	if x != nil {
		return x.ReturnThis
	}
	return nil
}

type ReturnErrorAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Failure       *v12.Failure           `protobuf:"bytes,1,opt,name=failure,proto3" json:"failure,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReturnErrorAction) Reset() {
	*x = ReturnErrorAction{}
	mi := &file_kitchen_sink_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReturnErrorAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReturnErrorAction) ProtoMessage() {}

func (x *ReturnErrorAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReturnErrorAction.ProtoReflect.Descriptor instead.
func (*ReturnErrorAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{33}
}

func (x *ReturnErrorAction) GetFailure() *v12.Failure {
	if x != nil {
		return x.Failure
	}
	return nil
}

type ContinueAsNewAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identifier the lang-specific sdk uses to execute workflow code
	WorkflowType string `protobuf:"bytes,1,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	// Task queue for the new workflow execution
	TaskQueue string `protobuf:"bytes,2,opt,name=task_queue,json=taskQueue,proto3" json:"task_queue,omitempty"`
	// Inputs to the workflow code. Should be specified. Will not re-use old arguments, as that
	// typically wouldn't make any sense.
	Arguments []*v1.Payload `protobuf:"bytes,3,rep,name=arguments,proto3" json:"arguments,omitempty"`
	// Timeout for a single run of the new workflow. Will not re-use current workflow's value.
	WorkflowRunTimeout *durationpb.Duration `protobuf:"bytes,4,opt,name=workflow_run_timeout,json=workflowRunTimeout,proto3" json:"workflow_run_timeout,omitempty"`
	// Timeout of a single workflow task. Will not re-use current workflow's value.
	WorkflowTaskTimeout *durationpb.Duration `protobuf:"bytes,5,opt,name=workflow_task_timeout,json=workflowTaskTimeout,proto3" json:"workflow_task_timeout,omitempty"`
	// If set, the new workflow will have this memo. If unset, re-uses the current workflow's memo
	Memo map[string]*v1.Payload `protobuf:"bytes,6,rep,name=memo,proto3" json:"memo,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If set, the new workflow will have these headers. Will *not* re-use current workflow's
	// headers otherwise.
	Headers map[string]*v1.Payload `protobuf:"bytes,7,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If set, the new workflow will have these search attributes. If unset, re-uses the current
	// workflow's search attributes.
	SearchAttributes map[string]*v1.Payload `protobuf:"bytes,8,rep,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If set, the new workflow will have this retry policy. If unset, re-uses the current
	// workflow's retry policy.
	RetryPolicy *v1.RetryPolicy `protobuf:"bytes,9,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// Whether the continued workflow should run on a worker with a compatible build id or not.
	VersioningIntent VersioningIntent `protobuf:"varint,10,opt,name=versioning_intent,json=versioningIntent,proto3,enum=temporal.omes.kitchen_sink.VersioningIntent" json:"versioning_intent,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ContinueAsNewAction) Reset() {
	*x = ContinueAsNewAction{}
	mi := &file_kitchen_sink_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContinueAsNewAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContinueAsNewAction) ProtoMessage() {}

func (x *ContinueAsNewAction) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContinueAsNewAction.ProtoReflect.Descriptor instead.
func (*ContinueAsNewAction) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{34}
}

func (x *ContinueAsNewAction) GetWorkflowType() string {
	if x != nil {
		return x.WorkflowType
	}
	return ""
}

func (x *ContinueAsNewAction) GetTaskQueue() string {
	if x != nil {
		return x.TaskQueue
	}
	return ""
}

func (x *ContinueAsNewAction) GetArguments() []*v1.Payload {
	if x != nil {
		return x.Arguments
	}
	return nil
}

func (x *ContinueAsNewAction) GetWorkflowRunTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowRunTimeout
	}
	return nil
}

func (x *ContinueAsNewAction) GetWorkflowTaskTimeout() *durationpb.Duration {
	if x != nil {
		return x.WorkflowTaskTimeout
	}
	return nil
}

func (x *ContinueAsNewAction) GetMemo() map[string]*v1.Payload {
	if x != nil {
		return x.Memo
	}
	return nil
}

func (x *ContinueAsNewAction) GetHeaders() map[string]*v1.Payload {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *ContinueAsNewAction) GetSearchAttributes() map[string]*v1.Payload {
	if x != nil {
		return x.SearchAttributes
	}
	return nil
}

func (x *ContinueAsNewAction) GetRetryPolicy() *v1.RetryPolicy {
	if x != nil {
		return x.RetryPolicy
	}
	return nil
}

func (x *ContinueAsNewAction) GetVersioningIntent() VersioningIntent {
	if x != nil {
		return x.VersioningIntent
	}
	return VersioningIntent_UNSPECIFIED
}

type RemoteActivityOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defines how the workflow will wait (or not) for cancellation of the activity to be confirmed
	CancellationType ActivityCancellationType `protobuf:"varint,1,opt,name=cancellation_type,json=cancellationType,proto3,enum=temporal.omes.kitchen_sink.ActivityCancellationType" json:"cancellation_type,omitempty"`
	// If set, the worker will not tell the service that it can immediately start executing this
	// activity. When unset/default, workers will always attempt to do so if activity execution
	// slots are available.
	DoNotEagerlyExecute bool `protobuf:"varint,2,opt,name=do_not_eagerly_execute,json=doNotEagerlyExecute,proto3" json:"do_not_eagerly_execute,omitempty"`
	// Whether this activity should run on a worker with a compatible build id or not.
	VersioningIntent VersioningIntent `protobuf:"varint,3,opt,name=versioning_intent,json=versioningIntent,proto3,enum=temporal.omes.kitchen_sink.VersioningIntent" json:"versioning_intent,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RemoteActivityOptions) Reset() {
	*x = RemoteActivityOptions{}
	mi := &file_kitchen_sink_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteActivityOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteActivityOptions) ProtoMessage() {}

func (x *RemoteActivityOptions) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteActivityOptions.ProtoReflect.Descriptor instead.
func (*RemoteActivityOptions) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{35}
}

func (x *RemoteActivityOptions) GetCancellationType() ActivityCancellationType {
	if x != nil {
		return x.CancellationType
	}
	return ActivityCancellationType_TRY_CANCEL
}

func (x *RemoteActivityOptions) GetDoNotEagerlyExecute() bool {
	if x != nil {
		return x.DoNotEagerlyExecute
	}
	return false
}

func (x *RemoteActivityOptions) GetVersioningIntent() VersioningIntent {
	if x != nil {
		return x.VersioningIntent
	}
	return VersioningIntent_UNSPECIFIED
}

// Execute a Nexus operation
type ExecuteNexusOperation struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Operation name to call
	Operation string `protobuf:"bytes,2,opt,name=operation,proto3" json:"operation,omitempty"`
	// Input payload for the operation
	Input string `protobuf:"bytes,3,opt,name=input,proto3" json:"input,omitempty"`
	// Headers to send with the operation
	Headers map[string]string `protobuf:"bytes,4,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// How to await on the operation
	AwaitableChoice *AwaitableChoice `protobuf:"bytes,5,opt,name=awaitable_choice,json=awaitableChoice,proto3" json:"awaitable_choice,omitempty"`
	// Expected output for verification
	ExpectedOutput string `protobuf:"bytes,6,opt,name=expected_output,json=expectedOutput,proto3" json:"expected_output,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ExecuteNexusOperation) Reset() {
	*x = ExecuteNexusOperation{}
	mi := &file_kitchen_sink_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteNexusOperation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteNexusOperation) ProtoMessage() {}

func (x *ExecuteNexusOperation) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteNexusOperation.ProtoReflect.Descriptor instead.
func (*ExecuteNexusOperation) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{36}
}

func (x *ExecuteNexusOperation) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *ExecuteNexusOperation) GetOperation() string {
	if x != nil {
		return x.Operation
	}
	return ""
}

func (x *ExecuteNexusOperation) GetInput() string {
	if x != nil {
		return x.Input
	}
	return ""
}

func (x *ExecuteNexusOperation) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *ExecuteNexusOperation) GetAwaitableChoice() *AwaitableChoice {
	if x != nil {
		return x.AwaitableChoice
	}
	return nil
}

func (x *ExecuteNexusOperation) GetExpectedOutput() string {
	if x != nil {
		return x.ExpectedOutput
	}
	return ""
}

type DoSignal_DoSignalActions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Variant:
	//
	//	*DoSignal_DoSignalActions_DoActions
	//	*DoSignal_DoSignalActions_DoActionsInMain
	Variant       isDoSignal_DoSignalActions_Variant `protobuf_oneof:"variant"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DoSignal_DoSignalActions) Reset() {
	*x = DoSignal_DoSignalActions{}
	mi := &file_kitchen_sink_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DoSignal_DoSignalActions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DoSignal_DoSignalActions) ProtoMessage() {}

func (x *DoSignal_DoSignalActions) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DoSignal_DoSignalActions.ProtoReflect.Descriptor instead.
func (*DoSignal_DoSignalActions) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{5, 0}
}

func (x *DoSignal_DoSignalActions) GetVariant() isDoSignal_DoSignalActions_Variant {
	if x != nil {
		return x.Variant
	}
	return nil
}

func (x *DoSignal_DoSignalActions) GetDoActions() *ActionSet {
	if x != nil {
		if x, ok := x.Variant.(*DoSignal_DoSignalActions_DoActions); ok {
			return x.DoActions
		}
	}
	return nil
}

func (x *DoSignal_DoSignalActions) GetDoActionsInMain() *ActionSet {
	if x != nil {
		if x, ok := x.Variant.(*DoSignal_DoSignalActions_DoActionsInMain); ok {
			return x.DoActionsInMain
		}
	}
	return nil
}

type isDoSignal_DoSignalActions_Variant interface {
	isDoSignal_DoSignalActions_Variant()
}

type DoSignal_DoSignalActions_DoActions struct {
	// Execute the action set in the handler. Since Go doesn't have explicit signal handlers it
	// should instead run the actions in a goroutine for both of these variants, as the
	// distinction doesn't really matter there.
	DoActions *ActionSet `protobuf:"bytes,1,opt,name=do_actions,json=doActions,proto3,oneof"`
}

type DoSignal_DoSignalActions_DoActionsInMain struct {
	// Pipe the actions back to the main workflow function via a queue or similar mechanism, where
	// they will then be run.
	DoActionsInMain *ActionSet `protobuf:"bytes,2,opt,name=do_actions_in_main,json=doActionsInMain,proto3,oneof"`
}

func (*DoSignal_DoSignalActions_DoActions) isDoSignal_DoSignalActions_Variant() {}

func (*DoSignal_DoSignalActions_DoActionsInMain) isDoSignal_DoSignalActions_Variant() {}

type ExecuteActivityAction_GenericActivity struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          string                 `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Arguments     []*v1.Payload          `protobuf:"bytes,2,rep,name=arguments,proto3" json:"arguments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteActivityAction_GenericActivity) Reset() {
	*x = ExecuteActivityAction_GenericActivity{}
	mi := &file_kitchen_sink_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteActivityAction_GenericActivity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteActivityAction_GenericActivity) ProtoMessage() {}

func (x *ExecuteActivityAction_GenericActivity) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteActivityAction_GenericActivity.ProtoReflect.Descriptor instead.
func (*ExecuteActivityAction_GenericActivity) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{24, 0}
}

func (x *ExecuteActivityAction_GenericActivity) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *ExecuteActivityAction_GenericActivity) GetArguments() []*v1.Payload {
	if x != nil {
		return x.Arguments
	}
	return nil
}

type ExecuteActivityAction_ResourcesActivity struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	RunFor                   *durationpb.Duration   `protobuf:"bytes,1,opt,name=run_for,json=runFor,proto3" json:"run_for,omitempty"`
	BytesToAllocate          uint64                 `protobuf:"varint,2,opt,name=bytes_to_allocate,json=bytesToAllocate,proto3" json:"bytes_to_allocate,omitempty"`
	CpuYieldEveryNIterations uint32                 `protobuf:"varint,3,opt,name=cpu_yield_every_n_iterations,json=cpuYieldEveryNIterations,proto3" json:"cpu_yield_every_n_iterations,omitempty"`
	CpuYieldForMs            uint32                 `protobuf:"varint,4,opt,name=cpu_yield_for_ms,json=cpuYieldForMs,proto3" json:"cpu_yield_for_ms,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *ExecuteActivityAction_ResourcesActivity) Reset() {
	*x = ExecuteActivityAction_ResourcesActivity{}
	mi := &file_kitchen_sink_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteActivityAction_ResourcesActivity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteActivityAction_ResourcesActivity) ProtoMessage() {}

func (x *ExecuteActivityAction_ResourcesActivity) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteActivityAction_ResourcesActivity.ProtoReflect.Descriptor instead.
func (*ExecuteActivityAction_ResourcesActivity) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{24, 1}
}

func (x *ExecuteActivityAction_ResourcesActivity) GetRunFor() *durationpb.Duration {
	if x != nil {
		return x.RunFor
	}
	return nil
}

func (x *ExecuteActivityAction_ResourcesActivity) GetBytesToAllocate() uint64 {
	if x != nil {
		return x.BytesToAllocate
	}
	return 0
}

func (x *ExecuteActivityAction_ResourcesActivity) GetCpuYieldEveryNIterations() uint32 {
	if x != nil {
		return x.CpuYieldEveryNIterations
	}
	return 0
}

func (x *ExecuteActivityAction_ResourcesActivity) GetCpuYieldForMs() uint32 {
	if x != nil {
		return x.CpuYieldForMs
	}
	return 0
}

type ExecuteActivityAction_PayloadActivity struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	BytesToReceive int32                  `protobuf:"varint,1,opt,name=bytes_to_receive,json=bytesToReceive,proto3" json:"bytes_to_receive,omitempty"`
	BytesToReturn  int32                  `protobuf:"varint,2,opt,name=bytes_to_return,json=bytesToReturn,proto3" json:"bytes_to_return,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ExecuteActivityAction_PayloadActivity) Reset() {
	*x = ExecuteActivityAction_PayloadActivity{}
	mi := &file_kitchen_sink_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteActivityAction_PayloadActivity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteActivityAction_PayloadActivity) ProtoMessage() {}

func (x *ExecuteActivityAction_PayloadActivity) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteActivityAction_PayloadActivity.ProtoReflect.Descriptor instead.
func (*ExecuteActivityAction_PayloadActivity) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{24, 2}
}

func (x *ExecuteActivityAction_PayloadActivity) GetBytesToReceive() int32 {
	if x != nil {
		return x.BytesToReceive
	}
	return 0
}

func (x *ExecuteActivityAction_PayloadActivity) GetBytesToReturn() int32 {
	if x != nil {
		return x.BytesToReturn
	}
	return 0
}

type ExecuteActivityAction_ClientActivity struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ClientSequence *ClientSequence        `protobuf:"bytes,1,opt,name=client_sequence,json=clientSequence,proto3" json:"client_sequence,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ExecuteActivityAction_ClientActivity) Reset() {
	*x = ExecuteActivityAction_ClientActivity{}
	mi := &file_kitchen_sink_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteActivityAction_ClientActivity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteActivityAction_ClientActivity) ProtoMessage() {}

func (x *ExecuteActivityAction_ClientActivity) ProtoReflect() protoreflect.Message {
	mi := &file_kitchen_sink_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteActivityAction_ClientActivity.ProtoReflect.Descriptor instead.
func (*ExecuteActivityAction_ClientActivity) Descriptor() ([]byte, []int) {
	return file_kitchen_sink_proto_rawDescGZIP(), []int{24, 3}
}

func (x *ExecuteActivityAction_ClientActivity) GetClientSequence() *ClientSequence {
	if x != nil {
		return x.ClientSequence
	}
	return nil
}

var File_kitchen_sink_proto protoreflect.FileDescriptor

const file_kitchen_sink_proto_rawDesc = "" +
	"\n" +
	"\x12kitchen_sink.proto\x12\x1atemporal.omes.kitchen_sink\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a$temporal/api/common/v1/message.proto\x1a%temporal/api/failure/v1/message.proto\x1a$temporal/api/enums/v1/workflow.proto\"\x91\x02\n" +
	"\tTestInput\x12P\n" +
	"\x0eworkflow_input\x18\x01 \x01(\v2).temporal.omes.kitchen_sink.WorkflowInputR\rworkflowInput\x12S\n" +
	"\x0fclient_sequence\x18\x02 \x01(\v2*.temporal.omes.kitchen_sink.ClientSequenceR\x0eclientSequence\x12]\n" +
	"\x11with_start_action\x18\x03 \x01(\v21.temporal.omes.kitchen_sink.WithStartClientActionR\x0fwithStartAction\"^\n" +
	"\x0eClientSequence\x12L\n" +
	"\vaction_sets\x18\x01 \x03(\v2+.temporal.omes.kitchen_sink.ClientActionSetR\n" +
	"actionSets\"\xff\x01\n" +
	"\x0fClientActionSet\x12B\n" +
	"\aactions\x18\x01 \x03(\v2(.temporal.omes.kitchen_sink.ClientActionR\aactions\x12\x1e\n" +
	"\n" +
	"concurrent\x18\x02 \x01(\bR\n" +
	"concurrent\x129\n" +
	"\vwait_at_end\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\twaitAtEnd\x12M\n" +
	"%wait_for_current_run_to_finish_at_end\x18\x04 \x01(\bR\x1ewaitForCurrentRunToFinishAtEnd\"\xac\x01\n" +
	"\x15WithStartClientAction\x12C\n" +
	"\tdo_signal\x18\x01 \x01(\v2$.temporal.omes.kitchen_sink.DoSignalH\x00R\bdoSignal\x12C\n" +
	"\tdo_update\x18\x02 \x01(\v2$.temporal.omes.kitchen_sink.DoUpdateH\x00R\bdoUpdateB\t\n" +
	"\avariant\"\xbb\x02\n" +
	"\fClientAction\x12C\n" +
	"\tdo_signal\x18\x01 \x01(\v2$.temporal.omes.kitchen_sink.DoSignalH\x00R\bdoSignal\x12@\n" +
	"\bdo_query\x18\x02 \x01(\v2#.temporal.omes.kitchen_sink.DoQueryH\x00R\adoQuery\x12C\n" +
	"\tdo_update\x18\x03 \x01(\v2$.temporal.omes.kitchen_sink.DoUpdateH\x00R\bdoUpdate\x12T\n" +
	"\x0enested_actions\x18\x04 \x01(\v2+.temporal.omes.kitchen_sink.ClientActionSetH\x00R\rnestedActionsB\t\n" +
	"\avariant\"\x9e\x03\n" +
	"\bDoSignal\x12b\n" +
	"\x11do_signal_actions\x18\x01 \x01(\v24.temporal.omes.kitchen_sink.DoSignal.DoSignalActionsH\x00R\x0fdoSignalActions\x12G\n" +
	"\x06custom\x18\x02 \x01(\v2-.temporal.omes.kitchen_sink.HandlerInvocationH\x00R\x06custom\x12\x1d\n" +
	"\n" +
	"with_start\x18\x03 \x01(\bR\twithStart\x1a\xba\x01\n" +
	"\x0fDoSignalActions\x12F\n" +
	"\n" +
	"do_actions\x18\x01 \x01(\v2%.temporal.omes.kitchen_sink.ActionSetH\x00R\tdoActions\x12T\n" +
	"\x12do_actions_in_main\x18\x02 \x01(\v2%.temporal.omes.kitchen_sink.ActionSetH\x00R\x0fdoActionsInMainB\t\n" +
	"\avariantB\t\n" +
	"\avariant\"\xcf\x01\n" +
	"\aDoQuery\x12E\n" +
	"\freport_state\x18\x01 \x01(\v2 .temporal.api.common.v1.PayloadsH\x00R\vreportState\x12G\n" +
	"\x06custom\x18\x02 \x01(\v2-.temporal.omes.kitchen_sink.HandlerInvocationH\x00R\x06custom\x12)\n" +
	"\x10failure_expected\x18\n" +
	" \x01(\bR\x0ffailureExpectedB\t\n" +
	"\avariant\"\xf6\x01\n" +
	"\bDoUpdate\x12L\n" +
	"\n" +
	"do_actions\x18\x01 \x01(\v2+.temporal.omes.kitchen_sink.DoActionsUpdateH\x00R\tdoActions\x12G\n" +
	"\x06custom\x18\x02 \x01(\v2-.temporal.omes.kitchen_sink.HandlerInvocationH\x00R\x06custom\x12\x1d\n" +
	"\n" +
	"with_start\x18\x03 \x01(\bR\twithStart\x12)\n" +
	"\x10failure_expected\x18\n" +
	" \x01(\bR\x0ffailureExpectedB\t\n" +
	"\avariant\"\x9b\x01\n" +
	"\x0fDoActionsUpdate\x12F\n" +
	"\n" +
	"do_actions\x18\x01 \x01(\v2%.temporal.omes.kitchen_sink.ActionSetH\x00R\tdoActions\x125\n" +
	"\treject_me\x18\x02 \x01(\v2\x16.google.protobuf.EmptyH\x00R\brejectMeB\t\n" +
	"\avariant\"\\\n" +
	"\x11HandlerInvocation\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x123\n" +
	"\x04args\x18\x02 \x03(\v2\x1f.temporal.api.common.v1.PayloadR\x04args\"\x8d\x01\n" +
	"\rWorkflowState\x12D\n" +
	"\x03kvs\x18\x01 \x03(\v22.temporal.omes.kitchen_sink.WorkflowState.KvsEntryR\x03kvs\x1a6\n" +
	"\bKvsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"_\n" +
	"\rWorkflowInput\x12N\n" +
	"\x0finitial_actions\x18\x01 \x03(\v2%.temporal.omes.kitchen_sink.ActionSetR\x0einitialActions\"i\n" +
	"\tActionSet\x12<\n" +
	"\aactions\x18\x01 \x03(\v2\".temporal.omes.kitchen_sink.ActionR\aactions\x12\x1e\n" +
	"\n" +
	"concurrent\x18\x02 \x01(\bR\n" +
	"concurrent\"l\n" +
	"\fScheduleSpec\x12)\n" +
	"\x10cron_expressions\x18\x01 \x03(\tR\x0fcronExpressions\x121\n" +
	"\x06jitter\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x06jitter\"\xa4\x03\n" +
	"\x0eScheduleAction\x12\x1f\n" +
	"\vworkflow_id\x18\x01 \x01(\tR\n" +
	"workflowId\x12#\n" +
	"\rworkflow_type\x18\x02 \x01(\tR\fworkflowType\x12\x1d\n" +
	"\n" +
	"task_queue\x18\x03 \x01(\tR\ttaskQueue\x12=\n" +
	"\targuments\x18\x04 \x03(\v2\x1f.temporal.api.common.v1.PayloadR\targuments\x12W\n" +
	"\x1aworkflow_execution_timeout\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x18workflowExecutionTimeout\x12M\n" +
	"\x15workflow_task_timeout\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\x13workflowTaskTimeout\x12F\n" +
	"\fretry_policy\x18\a \x01(\v2#.temporal.api.common.v1.RetryPolicyR\vretryPolicy\"\xb2\x01\n" +
	"\x10SchedulePolicies\x12+\n" +
	"\x11remaining_actions\x18\x01 \x01(\x03R\x10remainingActions\x12/\n" +
	"\x13trigger_immediately\x18\x02 \x01(\bR\x12triggerImmediately\x12@\n" +
	"\x0ecatchup_window\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\rcatchupWindow\"`\n" +
	"\x10ScheduleBackfill\x12'\n" +
	"\x0fstart_timestamp\x18\x01 \x01(\x03R\x0estartTimestamp\x12#\n" +
	"\rend_timestamp\x18\x02 \x01(\x03R\fendTimestamp\"\xcd\x02\n" +
	"\x14CreateScheduleAction\x12\x1f\n" +
	"\vschedule_id\x18\x01 \x01(\tR\n" +
	"scheduleId\x12<\n" +
	"\x04spec\x18\x02 \x01(\v2(.temporal.omes.kitchen_sink.ScheduleSpecR\x04spec\x12B\n" +
	"\x06action\x18\x03 \x01(\v2*.temporal.omes.kitchen_sink.ScheduleActionR\x06action\x12H\n" +
	"\bpolicies\x18\x04 \x01(\v2,.temporal.omes.kitchen_sink.SchedulePoliciesR\bpolicies\x12H\n" +
	"\bbackfill\x18\x05 \x03(\v2,.temporal.omes.kitchen_sink.ScheduleBackfillR\bbackfill\"9\n" +
	"\x16DescribeScheduleAction\x12\x1f\n" +
	"\vschedule_id\x18\x01 \x01(\tR\n" +
	"scheduleId\"u\n" +
	"\x14UpdateScheduleAction\x12\x1f\n" +
	"\vschedule_id\x18\x01 \x01(\tR\n" +
	"scheduleId\x12<\n" +
	"\x04spec\x18\x02 \x01(\v2(.temporal.omes.kitchen_sink.ScheduleSpecR\x04spec\"7\n" +
	"\x14DeleteScheduleAction\x12\x1f\n" +
	"\vschedule_id\x18\x01 \x01(\tR\n" +
	"scheduleId\"\xdd\r\n" +
	"\x06Action\x12?\n" +
	"\x05timer\x18\x01 \x01(\v2'.temporal.omes.kitchen_sink.TimerActionH\x00R\x05timer\x12X\n" +
	"\rexec_activity\x18\x02 \x01(\v21.temporal.omes.kitchen_sink.ExecuteActivityActionH\x00R\fexecActivity\x12h\n" +
	"\x13exec_child_workflow\x18\x03 \x01(\v26.temporal.omes.kitchen_sink.ExecuteChildWorkflowActionH\x00R\x11execChildWorkflow\x12b\n" +
	"\x14await_workflow_state\x18\x04 \x01(\v2..temporal.omes.kitchen_sink.AwaitWorkflowStateH\x00R\x12awaitWorkflowState\x12O\n" +
	"\vsend_signal\x18\x05 \x01(\v2,.temporal.omes.kitchen_sink.SendSignalActionH\x00R\n" +
	"sendSignal\x12[\n" +
	"\x0fcancel_workflow\x18\x06 \x01(\v20.temporal.omes.kitchen_sink.CancelWorkflowActionH\x00R\x0ecancelWorkflow\x12\\\n" +
	"\x10set_patch_marker\x18\a \x01(\v20.temporal.omes.kitchen_sink.SetPatchMarkerActionH\x00R\x0esetPatchMarker\x12t\n" +
	"\x18upsert_search_attributes\x18\b \x01(\v28.temporal.omes.kitchen_sink.UpsertSearchAttributesActionH\x00R\x16upsertSearchAttributes\x12O\n" +
	"\vupsert_memo\x18\t \x01(\v2,.temporal.omes.kitchen_sink.UpsertMemoActionH\x00R\n" +
	"upsertMemo\x12Y\n" +
	"\x12set_workflow_state\x18\n" +
	" \x01(\v2).temporal.omes.kitchen_sink.WorkflowStateH\x00R\x10setWorkflowState\x12U\n" +
	"\rreturn_result\x18\v \x01(\v2..temporal.omes.kitchen_sink.ReturnResultActionH\x00R\freturnResult\x12R\n" +
	"\freturn_error\x18\f \x01(\v2-.temporal.omes.kitchen_sink.ReturnErrorActionH\x00R\vreturnError\x12Y\n" +
	"\x0fcontinue_as_new\x18\r \x01(\v2/.temporal.omes.kitchen_sink.ContinueAsNewActionH\x00R\rcontinueAsNew\x12S\n" +
	"\x11nested_action_set\x18\x0e \x01(\v2%.temporal.omes.kitchen_sink.ActionSetH\x00R\x0fnestedActionSet\x12\\\n" +
	"\x0fnexus_operation\x18\x0f \x01(\v21.temporal.omes.kitchen_sink.ExecuteNexusOperationH\x00R\x0enexusOperation\x12[\n" +
	"\x0fcreate_schedule\x18\x10 \x01(\v20.temporal.omes.kitchen_sink.CreateScheduleActionH\x00R\x0ecreateSchedule\x12a\n" +
	"\x11describe_schedule\x18\x11 \x01(\v22.temporal.omes.kitchen_sink.DescribeScheduleActionH\x00R\x10describeSchedule\x12[\n" +
	"\x0fupdate_schedule\x18\x12 \x01(\v20.temporal.omes.kitchen_sink.UpdateScheduleActionH\x00R\x0eupdateSchedule\x12[\n" +
	"\x0fdelete_schedule\x18\x13 \x01(\v20.temporal.omes.kitchen_sink.DeleteScheduleActionH\x00R\x0edeleteScheduleB\t\n" +
	"\avariant\"\xf7\x02\n" +
	"\x0fAwaitableChoice\x129\n" +
	"\vwait_finish\x18\x01 \x01(\v2\x16.google.protobuf.EmptyH\x00R\n" +
	"waitFinish\x122\n" +
	"\aabandon\x18\x02 \x01(\v2\x16.google.protobuf.EmptyH\x00R\aabandon\x12L\n" +
	"\x15cancel_before_started\x18\x03 \x01(\v2\x16.google.protobuf.EmptyH\x00R\x13cancelBeforeStarted\x12J\n" +
	"\x14cancel_after_started\x18\x04 \x01(\v2\x16.google.protobuf.EmptyH\x00R\x12cancelAfterStarted\x12N\n" +
	"\x16cancel_after_completed\x18\x05 \x01(\v2\x16.google.protobuf.EmptyH\x00R\x14cancelAfterCompletedB\v\n" +
	"\tcondition\"\x89\x01\n" +
	"\vTimerAction\x12\"\n" +
	"\fmilliseconds\x18\x01 \x01(\x04R\fmilliseconds\x12V\n" +
	"\x10awaitable_choice\x18\x02 \x01(\v2+.temporal.omes.kitchen_sink.AwaitableChoiceR\x0fawaitableChoice\"\xeb\x0f\n" +
	"\x15ExecuteActivityAction\x12]\n" +
	"\ageneric\x18\x01 \x01(\v2A.temporal.omes.kitchen_sink.ExecuteActivityAction.GenericActivityH\x00R\ageneric\x121\n" +
	"\x05delay\x18\x02 \x01(\v2\x19.google.protobuf.DurationH\x00R\x05delay\x12,\n" +
	"\x04noop\x18\x03 \x01(\v2\x16.google.protobuf.EmptyH\x00R\x04noop\x12c\n" +
	"\tresources\x18\x0e \x01(\v2C.temporal.omes.kitchen_sink.ExecuteActivityAction.ResourcesActivityH\x00R\tresources\x12]\n" +
	"\apayload\x18\x12 \x01(\v2A.temporal.omes.kitchen_sink.ExecuteActivityAction.PayloadActivityH\x00R\apayload\x12Z\n" +
	"\x06client\x18\x13 \x01(\v2@.temporal.omes.kitchen_sink.ExecuteActivityAction.ClientActivityH\x00R\x06client\x12\x1d\n" +
	"\n" +
	"task_queue\x18\x04 \x01(\tR\ttaskQueue\x12X\n" +
	"\aheaders\x18\x05 \x03(\v2>.temporal.omes.kitchen_sink.ExecuteActivityAction.HeadersEntryR\aheaders\x12T\n" +
	"\x19schedule_to_close_timeout\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\x16scheduleToCloseTimeout\x12T\n" +
	"\x19schedule_to_start_timeout\x18\a \x01(\v2\x19.google.protobuf.DurationR\x16scheduleToStartTimeout\x12N\n" +
	"\x16start_to_close_timeout\x18\b \x01(\v2\x19.google.protobuf.DurationR\x13startToCloseTimeout\x12F\n" +
	"\x11heartbeat_timeout\x18\t \x01(\v2\x19.google.protobuf.DurationR\x10heartbeatTimeout\x12F\n" +
	"\fretry_policy\x18\n" +
	" \x01(\v2#.temporal.api.common.v1.RetryPolicyR\vretryPolicy\x123\n" +
	"\bis_local\x18\v \x01(\v2\x16.google.protobuf.EmptyH\x01R\aisLocal\x12K\n" +
	"\x06remote\x18\f \x01(\v21.temporal.omes.kitchen_sink.RemoteActivityOptionsH\x01R\x06remote\x12V\n" +
	"\x10awaitable_choice\x18\r \x01(\v2+.temporal.omes.kitchen_sink.AwaitableChoiceR\x0fawaitableChoice\x12<\n" +
	"\bpriority\x18\x0f \x01(\v2 .temporal.api.common.v1.PriorityR\bpriority\x12!\n" +
	"\ffairness_key\x18\x10 \x01(\tR\vfairnessKey\x12'\n" +
	"\x0ffairness_weight\x18\x11 \x01(\x02R\x0efairnessWeight\x1ad\n" +
	"\x0fGenericActivity\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12=\n" +
	"\targuments\x18\x02 \x03(\v2\x1f.temporal.api.common.v1.PayloadR\targuments\x1a\xdc\x01\n" +
	"\x11ResourcesActivity\x122\n" +
	"\arun_for\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\x06runFor\x12*\n" +
	"\x11bytes_to_allocate\x18\x02 \x01(\x04R\x0fbytesToAllocate\x12>\n" +
	"\x1ccpu_yield_every_n_iterations\x18\x03 \x01(\rR\x18cpuYieldEveryNIterations\x12'\n" +
	"\x10cpu_yield_for_ms\x18\x04 \x01(\rR\rcpuYieldForMs\x1ac\n" +
	"\x0fPayloadActivity\x12(\n" +
	"\x10bytes_to_receive\x18\x01 \x01(\x05R\x0ebytesToReceive\x12&\n" +
	"\x0fbytes_to_return\x18\x02 \x01(\x05R\rbytesToReturn\x1ae\n" +
	"\x0eClientActivity\x12S\n" +
	"\x0fclient_sequence\x18\x01 \x01(\v2*.temporal.omes.kitchen_sink.ClientSequenceR\x0eclientSequence\x1a[\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01B\x0f\n" +
	"\ractivity_typeB\n" +
	"\n" +
	"\blocality\"\xe6\f\n" +
	"\x1aExecuteChildWorkflowAction\x12\x1c\n" +
	"\tnamespace\x18\x02 \x01(\tR\tnamespace\x12\x1f\n" +
	"\vworkflow_id\x18\x03 \x01(\tR\n" +
	"workflowId\x12#\n" +
	"\rworkflow_type\x18\x04 \x01(\tR\fworkflowType\x12\x1d\n" +
	"\n" +
	"task_queue\x18\x05 \x01(\tR\ttaskQueue\x125\n" +
	"\x05input\x18\x06 \x03(\v2\x1f.temporal.api.common.v1.PayloadR\x05input\x12W\n" +
	"\x1aworkflow_execution_timeout\x18\a \x01(\v2\x19.google.protobuf.DurationR\x18workflowExecutionTimeout\x12K\n" +
	"\x14workflow_run_timeout\x18\b \x01(\v2\x19.google.protobuf.DurationR\x12workflowRunTimeout\x12M\n" +
	"\x15workflow_task_timeout\x18\t \x01(\v2\x19.google.protobuf.DurationR\x13workflowTaskTimeout\x12]\n" +
	"\x13parent_close_policy\x18\n" +
	" \x01(\x0e2-.temporal.omes.kitchen_sink.ParentClosePolicyR\x11parentClosePolicy\x12e\n" +
	"\x18workflow_id_reuse_policy\x18\f \x01(\x0e2,.temporal.api.enums.v1.WorkflowIdReusePolicyR\x15workflowIdReusePolicy\x12F\n" +
	"\fretry_policy\x18\r \x01(\v2#.temporal.api.common.v1.RetryPolicyR\vretryPolicy\x12#\n" +
	"\rcron_schedule\x18\x0e \x01(\tR\fcronSchedule\x12]\n" +
	"\aheaders\x18\x0f \x03(\v2C.temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.HeadersEntryR\aheaders\x12T\n" +
	"\x04memo\x18\x10 \x03(\v2@.temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.MemoEntryR\x04memo\x12y\n" +
	"\x11search_attributes\x18\x11 \x03(\v2L.temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.SearchAttributesEntryR\x10searchAttributes\x12f\n" +
	"\x11cancellation_type\x18\x12 \x01(\x0e29.temporal.omes.kitchen_sink.ChildWorkflowCancellationTypeR\x10cancellationType\x12Y\n" +
	"\x11versioning_intent\x18\x13 \x01(\x0e2,.temporal.omes.kitchen_sink.VersioningIntentR\x10versioningIntent\x12V\n" +
	"\x10awaitable_choice\x18\x14 \x01(\v2+.temporal.omes.kitchen_sink.AwaitableChoiceR\x0fawaitableChoice\x1a[\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\x1aX\n" +
	"\tMemoEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\x1ad\n" +
	"\x15SearchAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\"<\n" +
	"\x12AwaitWorkflowState\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"\xaa\x03\n" +
	"\x10SendSignalAction\x12\x1f\n" +
	"\vworkflow_id\x18\x01 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x02 \x01(\tR\x05runId\x12\x1f\n" +
	"\vsignal_name\x18\x03 \x01(\tR\n" +
	"signalName\x123\n" +
	"\x04args\x18\x04 \x03(\v2\x1f.temporal.api.common.v1.PayloadR\x04args\x12S\n" +
	"\aheaders\x18\x05 \x03(\v29.temporal.omes.kitchen_sink.SendSignalAction.HeadersEntryR\aheaders\x12V\n" +
	"\x10awaitable_choice\x18\x06 \x01(\v2+.temporal.omes.kitchen_sink.AwaitableChoiceR\x0fawaitableChoice\x1a[\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\"N\n" +
	"\x14CancelWorkflowAction\x12\x1f\n" +
	"\vworkflow_id\x18\x01 \x01(\tR\n" +
	"workflowId\x12\x15\n" +
	"\x06run_id\x18\x02 \x01(\tR\x05runId\"\x98\x01\n" +
	"\x14SetPatchMarkerAction\x12\x19\n" +
	"\bpatch_id\x18\x01 \x01(\tR\apatchId\x12\x1e\n" +
	"\n" +
	"deprecated\x18\x02 \x01(\bR\n" +
	"deprecated\x12E\n" +
	"\finner_action\x18\x03 \x01(\v2\".temporal.omes.kitchen_sink.ActionR\vinnerAction\"\x81\x02\n" +
	"\x1cUpsertSearchAttributesAction\x12{\n" +
	"\x11search_attributes\x18\x01 \x03(\v2N.temporal.omes.kitchen_sink.UpsertSearchAttributesAction.SearchAttributesEntryR\x10searchAttributes\x1ad\n" +
	"\x15SearchAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\"U\n" +
	"\x10UpsertMemoAction\x12A\n" +
	"\rupserted_memo\x18\x01 \x01(\v2\x1c.temporal.api.common.v1.MemoR\fupsertedMemo\"V\n" +
	"\x12ReturnResultAction\x12@\n" +
	"\vreturn_this\x18\x01 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\n" +
	"returnThis\"O\n" +
	"\x11ReturnErrorAction\x12:\n" +
	"\afailure\x18\x01 \x01(\v2 .temporal.api.failure.v1.FailureR\afailure\"\x8f\b\n" +
	"\x13ContinueAsNewAction\x12#\n" +
	"\rworkflow_type\x18\x01 \x01(\tR\fworkflowType\x12\x1d\n" +
	"\n" +
	"task_queue\x18\x02 \x01(\tR\ttaskQueue\x12=\n" +
	"\targuments\x18\x03 \x03(\v2\x1f.temporal.api.common.v1.PayloadR\targuments\x12K\n" +
	"\x14workflow_run_timeout\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x12workflowRunTimeout\x12M\n" +
	"\x15workflow_task_timeout\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x13workflowTaskTimeout\x12M\n" +
	"\x04memo\x18\x06 \x03(\v29.temporal.omes.kitchen_sink.ContinueAsNewAction.MemoEntryR\x04memo\x12V\n" +
	"\aheaders\x18\a \x03(\v2<.temporal.omes.kitchen_sink.ContinueAsNewAction.HeadersEntryR\aheaders\x12r\n" +
	"\x11search_attributes\x18\b \x03(\v2E.temporal.omes.kitchen_sink.ContinueAsNewAction.SearchAttributesEntryR\x10searchAttributes\x12F\n" +
	"\fretry_policy\x18\t \x01(\v2#.temporal.api.common.v1.RetryPolicyR\vretryPolicy\x12Y\n" +
	"\x11versioning_intent\x18\n" +
	" \x01(\x0e2,.temporal.omes.kitchen_sink.VersioningIntentR\x10versioningIntent\x1aX\n" +
	"\tMemoEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\x1a[\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\x1ad\n" +
	"\x15SearchAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x125\n" +
	"\x05value\x18\x02 \x01(\v2\x1f.temporal.api.common.v1.PayloadR\x05value:\x028\x01\"\x8a\x02\n" +
	"\x15RemoteActivityOptions\x12a\n" +
	"\x11cancellation_type\x18\x01 \x01(\x0e24.temporal.omes.kitchen_sink.ActivityCancellationTypeR\x10cancellationType\x123\n" +
	"\x16do_not_eagerly_execute\x18\x02 \x01(\bR\x13doNotEagerlyExecute\x12Y\n" +
	"\x11versioning_intent\x18\x03 \x01(\x0e2,.temporal.omes.kitchen_sink.VersioningIntentR\x10versioningIntent\"\xfe\x02\n" +
	"\x15ExecuteNexusOperation\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x1c\n" +
	"\toperation\x18\x02 \x01(\tR\toperation\x12\x14\n" +
	"\x05input\x18\x03 \x01(\tR\x05input\x12X\n" +
	"\aheaders\x18\x04 \x03(\v2>.temporal.omes.kitchen_sink.ExecuteNexusOperation.HeadersEntryR\aheaders\x12V\n" +
	"\x10awaitable_choice\x18\x05 \x01(\v2+.temporal.omes.kitchen_sink.AwaitableChoiceR\x0fawaitableChoice\x12'\n" +
	"\x0fexpected_output\x18\x06 \x01(\tR\x0eexpectedOutput\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01*\xa4\x01\n" +
	"\x11ParentClosePolicy\x12#\n" +
	"\x1fPARENT_CLOSE_POLICY_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dPARENT_CLOSE_POLICY_TERMINATE\x10\x01\x12\x1f\n" +
	"\x1bPARENT_CLOSE_POLICY_ABANDON\x10\x02\x12&\n" +
	"\"PARENT_CLOSE_POLICY_REQUEST_CANCEL\x10\x03*@\n" +
	"\x10VersioningIntent\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"COMPATIBLE\x10\x01\x12\v\n" +
	"\aDEFAULT\x10\x02*\xa2\x01\n" +
	"\x1dChildWorkflowCancellationType\x12\x14\n" +
	"\x10CHILD_WF_ABANDON\x10\x00\x12\x17\n" +
	"\x13CHILD_WF_TRY_CANCEL\x10\x01\x12(\n" +
	"$CHILD_WF_WAIT_CANCELLATION_COMPLETED\x10\x02\x12(\n" +
	"$CHILD_WF_WAIT_CANCELLATION_REQUESTED\x10\x03*X\n" +
	"\x18ActivityCancellationType\x12\x0e\n" +
	"\n" +
	"TRY_CANCEL\x10\x00\x12\x1f\n" +
	"\x1bWAIT_CANCELLATION_COMPLETED\x10\x01\x12\v\n" +
	"\aABANDON\x10\x02BB\n" +
	"\x10io.temporal.omesZ.github.com/temporalio/omes/loadgen/kitchensinkb\x06proto3"

var (
	file_kitchen_sink_proto_rawDescOnce sync.Once
	file_kitchen_sink_proto_rawDescData []byte
)

func file_kitchen_sink_proto_rawDescGZIP() []byte {
	file_kitchen_sink_proto_rawDescOnce.Do(func() {
		file_kitchen_sink_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_kitchen_sink_proto_rawDesc), len(file_kitchen_sink_proto_rawDesc)))
	})
	return file_kitchen_sink_proto_rawDescData
}

var file_kitchen_sink_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_kitchen_sink_proto_msgTypes = make([]protoimpl.MessageInfo, 53)
var file_kitchen_sink_proto_goTypes = []any{
	(ParentClosePolicy)(0),                          // 0: temporal.omes.kitchen_sink.ParentClosePolicy
	(VersioningIntent)(0),                           // 1: temporal.omes.kitchen_sink.VersioningIntent
	(ChildWorkflowCancellationType)(0),              // 2: temporal.omes.kitchen_sink.ChildWorkflowCancellationType
	(ActivityCancellationType)(0),                   // 3: temporal.omes.kitchen_sink.ActivityCancellationType
	(*TestInput)(nil),                               // 4: temporal.omes.kitchen_sink.TestInput
	(*ClientSequence)(nil),                          // 5: temporal.omes.kitchen_sink.ClientSequence
	(*ClientActionSet)(nil),                         // 6: temporal.omes.kitchen_sink.ClientActionSet
	(*WithStartClientAction)(nil),                   // 7: temporal.omes.kitchen_sink.WithStartClientAction
	(*ClientAction)(nil),                            // 8: temporal.omes.kitchen_sink.ClientAction
	(*DoSignal)(nil),                                // 9: temporal.omes.kitchen_sink.DoSignal
	(*DoQuery)(nil),                                 // 10: temporal.omes.kitchen_sink.DoQuery
	(*DoUpdate)(nil),                                // 11: temporal.omes.kitchen_sink.DoUpdate
	(*DoActionsUpdate)(nil),                         // 12: temporal.omes.kitchen_sink.DoActionsUpdate
	(*HandlerInvocation)(nil),                       // 13: temporal.omes.kitchen_sink.HandlerInvocation
	(*WorkflowState)(nil),                           // 14: temporal.omes.kitchen_sink.WorkflowState
	(*WorkflowInput)(nil),                           // 15: temporal.omes.kitchen_sink.WorkflowInput
	(*ActionSet)(nil),                               // 16: temporal.omes.kitchen_sink.ActionSet
	(*ScheduleSpec)(nil),                            // 17: temporal.omes.kitchen_sink.ScheduleSpec
	(*ScheduleAction)(nil),                          // 18: temporal.omes.kitchen_sink.ScheduleAction
	(*SchedulePolicies)(nil),                        // 19: temporal.omes.kitchen_sink.SchedulePolicies
	(*ScheduleBackfill)(nil),                        // 20: temporal.omes.kitchen_sink.ScheduleBackfill
	(*CreateScheduleAction)(nil),                    // 21: temporal.omes.kitchen_sink.CreateScheduleAction
	(*DescribeScheduleAction)(nil),                  // 22: temporal.omes.kitchen_sink.DescribeScheduleAction
	(*UpdateScheduleAction)(nil),                    // 23: temporal.omes.kitchen_sink.UpdateScheduleAction
	(*DeleteScheduleAction)(nil),                    // 24: temporal.omes.kitchen_sink.DeleteScheduleAction
	(*Action)(nil),                                  // 25: temporal.omes.kitchen_sink.Action
	(*AwaitableChoice)(nil),                         // 26: temporal.omes.kitchen_sink.AwaitableChoice
	(*TimerAction)(nil),                             // 27: temporal.omes.kitchen_sink.TimerAction
	(*ExecuteActivityAction)(nil),                   // 28: temporal.omes.kitchen_sink.ExecuteActivityAction
	(*ExecuteChildWorkflowAction)(nil),              // 29: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction
	(*AwaitWorkflowState)(nil),                      // 30: temporal.omes.kitchen_sink.AwaitWorkflowState
	(*SendSignalAction)(nil),                        // 31: temporal.omes.kitchen_sink.SendSignalAction
	(*CancelWorkflowAction)(nil),                    // 32: temporal.omes.kitchen_sink.CancelWorkflowAction
	(*SetPatchMarkerAction)(nil),                    // 33: temporal.omes.kitchen_sink.SetPatchMarkerAction
	(*UpsertSearchAttributesAction)(nil),            // 34: temporal.omes.kitchen_sink.UpsertSearchAttributesAction
	(*UpsertMemoAction)(nil),                        // 35: temporal.omes.kitchen_sink.UpsertMemoAction
	(*ReturnResultAction)(nil),                      // 36: temporal.omes.kitchen_sink.ReturnResultAction
	(*ReturnErrorAction)(nil),                       // 37: temporal.omes.kitchen_sink.ReturnErrorAction
	(*ContinueAsNewAction)(nil),                     // 38: temporal.omes.kitchen_sink.ContinueAsNewAction
	(*RemoteActivityOptions)(nil),                   // 39: temporal.omes.kitchen_sink.RemoteActivityOptions
	(*ExecuteNexusOperation)(nil),                   // 40: temporal.omes.kitchen_sink.ExecuteNexusOperation
	(*DoSignal_DoSignalActions)(nil),                // 41: temporal.omes.kitchen_sink.DoSignal.DoSignalActions
	nil,                                             // 42: temporal.omes.kitchen_sink.WorkflowState.KvsEntry
	(*ExecuteActivityAction_GenericActivity)(nil),   // 43: temporal.omes.kitchen_sink.ExecuteActivityAction.GenericActivity
	(*ExecuteActivityAction_ResourcesActivity)(nil), // 44: temporal.omes.kitchen_sink.ExecuteActivityAction.ResourcesActivity
	(*ExecuteActivityAction_PayloadActivity)(nil),   // 45: temporal.omes.kitchen_sink.ExecuteActivityAction.PayloadActivity
	(*ExecuteActivityAction_ClientActivity)(nil),    // 46: temporal.omes.kitchen_sink.ExecuteActivityAction.ClientActivity
	nil,                            // 47: temporal.omes.kitchen_sink.ExecuteActivityAction.HeadersEntry
	nil,                            // 48: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.HeadersEntry
	nil,                            // 49: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.MemoEntry
	nil,                            // 50: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.SearchAttributesEntry
	nil,                            // 51: temporal.omes.kitchen_sink.SendSignalAction.HeadersEntry
	nil,                            // 52: temporal.omes.kitchen_sink.UpsertSearchAttributesAction.SearchAttributesEntry
	nil,                            // 53: temporal.omes.kitchen_sink.ContinueAsNewAction.MemoEntry
	nil,                            // 54: temporal.omes.kitchen_sink.ContinueAsNewAction.HeadersEntry
	nil,                            // 55: temporal.omes.kitchen_sink.ContinueAsNewAction.SearchAttributesEntry
	nil,                            // 56: temporal.omes.kitchen_sink.ExecuteNexusOperation.HeadersEntry
	(*durationpb.Duration)(nil),    // 57: google.protobuf.Duration
	(*v1.Payloads)(nil),            // 58: temporal.api.common.v1.Payloads
	(*emptypb.Empty)(nil),          // 59: google.protobuf.Empty
	(*v1.Payload)(nil),             // 60: temporal.api.common.v1.Payload
	(*v1.RetryPolicy)(nil),         // 61: temporal.api.common.v1.RetryPolicy
	(*v1.Priority)(nil),            // 62: temporal.api.common.v1.Priority
	(v11.WorkflowIdReusePolicy)(0), // 63: temporal.api.enums.v1.WorkflowIdReusePolicy
	(*v1.Memo)(nil),                // 64: temporal.api.common.v1.Memo
	(*v12.Failure)(nil),            // 65: temporal.api.failure.v1.Failure
}
var file_kitchen_sink_proto_depIdxs = []int32{
	15,  // 0: temporal.omes.kitchen_sink.TestInput.workflow_input:type_name -> temporal.omes.kitchen_sink.WorkflowInput
	5,   // 1: temporal.omes.kitchen_sink.TestInput.client_sequence:type_name -> temporal.omes.kitchen_sink.ClientSequence
	7,   // 2: temporal.omes.kitchen_sink.TestInput.with_start_action:type_name -> temporal.omes.kitchen_sink.WithStartClientAction
	6,   // 3: temporal.omes.kitchen_sink.ClientSequence.action_sets:type_name -> temporal.omes.kitchen_sink.ClientActionSet
	8,   // 4: temporal.omes.kitchen_sink.ClientActionSet.actions:type_name -> temporal.omes.kitchen_sink.ClientAction
	57,  // 5: temporal.omes.kitchen_sink.ClientActionSet.wait_at_end:type_name -> google.protobuf.Duration
	9,   // 6: temporal.omes.kitchen_sink.WithStartClientAction.do_signal:type_name -> temporal.omes.kitchen_sink.DoSignal
	11,  // 7: temporal.omes.kitchen_sink.WithStartClientAction.do_update:type_name -> temporal.omes.kitchen_sink.DoUpdate
	9,   // 8: temporal.omes.kitchen_sink.ClientAction.do_signal:type_name -> temporal.omes.kitchen_sink.DoSignal
	10,  // 9: temporal.omes.kitchen_sink.ClientAction.do_query:type_name -> temporal.omes.kitchen_sink.DoQuery
	11,  // 10: temporal.omes.kitchen_sink.ClientAction.do_update:type_name -> temporal.omes.kitchen_sink.DoUpdate
	6,   // 11: temporal.omes.kitchen_sink.ClientAction.nested_actions:type_name -> temporal.omes.kitchen_sink.ClientActionSet
	41,  // 12: temporal.omes.kitchen_sink.DoSignal.do_signal_actions:type_name -> temporal.omes.kitchen_sink.DoSignal.DoSignalActions
	13,  // 13: temporal.omes.kitchen_sink.DoSignal.custom:type_name -> temporal.omes.kitchen_sink.HandlerInvocation
	58,  // 14: temporal.omes.kitchen_sink.DoQuery.report_state:type_name -> temporal.api.common.v1.Payloads
	13,  // 15: temporal.omes.kitchen_sink.DoQuery.custom:type_name -> temporal.omes.kitchen_sink.HandlerInvocation
	12,  // 16: temporal.omes.kitchen_sink.DoUpdate.do_actions:type_name -> temporal.omes.kitchen_sink.DoActionsUpdate
	13,  // 17: temporal.omes.kitchen_sink.DoUpdate.custom:type_name -> temporal.omes.kitchen_sink.HandlerInvocation
	16,  // 18: temporal.omes.kitchen_sink.DoActionsUpdate.do_actions:type_name -> temporal.omes.kitchen_sink.ActionSet
	59,  // 19: temporal.omes.kitchen_sink.DoActionsUpdate.reject_me:type_name -> google.protobuf.Empty
	60,  // 20: temporal.omes.kitchen_sink.HandlerInvocation.args:type_name -> temporal.api.common.v1.Payload
	42,  // 21: temporal.omes.kitchen_sink.WorkflowState.kvs:type_name -> temporal.omes.kitchen_sink.WorkflowState.KvsEntry
	16,  // 22: temporal.omes.kitchen_sink.WorkflowInput.initial_actions:type_name -> temporal.omes.kitchen_sink.ActionSet
	25,  // 23: temporal.omes.kitchen_sink.ActionSet.actions:type_name -> temporal.omes.kitchen_sink.Action
	57,  // 24: temporal.omes.kitchen_sink.ScheduleSpec.jitter:type_name -> google.protobuf.Duration
	60,  // 25: temporal.omes.kitchen_sink.ScheduleAction.arguments:type_name -> temporal.api.common.v1.Payload
	57,  // 26: temporal.omes.kitchen_sink.ScheduleAction.workflow_execution_timeout:type_name -> google.protobuf.Duration
	57,  // 27: temporal.omes.kitchen_sink.ScheduleAction.workflow_task_timeout:type_name -> google.protobuf.Duration
	61,  // 28: temporal.omes.kitchen_sink.ScheduleAction.retry_policy:type_name -> temporal.api.common.v1.RetryPolicy
	57,  // 29: temporal.omes.kitchen_sink.SchedulePolicies.catchup_window:type_name -> google.protobuf.Duration
	17,  // 30: temporal.omes.kitchen_sink.CreateScheduleAction.spec:type_name -> temporal.omes.kitchen_sink.ScheduleSpec
	18,  // 31: temporal.omes.kitchen_sink.CreateScheduleAction.action:type_name -> temporal.omes.kitchen_sink.ScheduleAction
	19,  // 32: temporal.omes.kitchen_sink.CreateScheduleAction.policies:type_name -> temporal.omes.kitchen_sink.SchedulePolicies
	20,  // 33: temporal.omes.kitchen_sink.CreateScheduleAction.backfill:type_name -> temporal.omes.kitchen_sink.ScheduleBackfill
	17,  // 34: temporal.omes.kitchen_sink.UpdateScheduleAction.spec:type_name -> temporal.omes.kitchen_sink.ScheduleSpec
	27,  // 35: temporal.omes.kitchen_sink.Action.timer:type_name -> temporal.omes.kitchen_sink.TimerAction
	28,  // 36: temporal.omes.kitchen_sink.Action.exec_activity:type_name -> temporal.omes.kitchen_sink.ExecuteActivityAction
	29,  // 37: temporal.omes.kitchen_sink.Action.exec_child_workflow:type_name -> temporal.omes.kitchen_sink.ExecuteChildWorkflowAction
	30,  // 38: temporal.omes.kitchen_sink.Action.await_workflow_state:type_name -> temporal.omes.kitchen_sink.AwaitWorkflowState
	31,  // 39: temporal.omes.kitchen_sink.Action.send_signal:type_name -> temporal.omes.kitchen_sink.SendSignalAction
	32,  // 40: temporal.omes.kitchen_sink.Action.cancel_workflow:type_name -> temporal.omes.kitchen_sink.CancelWorkflowAction
	33,  // 41: temporal.omes.kitchen_sink.Action.set_patch_marker:type_name -> temporal.omes.kitchen_sink.SetPatchMarkerAction
	34,  // 42: temporal.omes.kitchen_sink.Action.upsert_search_attributes:type_name -> temporal.omes.kitchen_sink.UpsertSearchAttributesAction
	35,  // 43: temporal.omes.kitchen_sink.Action.upsert_memo:type_name -> temporal.omes.kitchen_sink.UpsertMemoAction
	14,  // 44: temporal.omes.kitchen_sink.Action.set_workflow_state:type_name -> temporal.omes.kitchen_sink.WorkflowState
	36,  // 45: temporal.omes.kitchen_sink.Action.return_result:type_name -> temporal.omes.kitchen_sink.ReturnResultAction
	37,  // 46: temporal.omes.kitchen_sink.Action.return_error:type_name -> temporal.omes.kitchen_sink.ReturnErrorAction
	38,  // 47: temporal.omes.kitchen_sink.Action.continue_as_new:type_name -> temporal.omes.kitchen_sink.ContinueAsNewAction
	16,  // 48: temporal.omes.kitchen_sink.Action.nested_action_set:type_name -> temporal.omes.kitchen_sink.ActionSet
	40,  // 49: temporal.omes.kitchen_sink.Action.nexus_operation:type_name -> temporal.omes.kitchen_sink.ExecuteNexusOperation
	21,  // 50: temporal.omes.kitchen_sink.Action.create_schedule:type_name -> temporal.omes.kitchen_sink.CreateScheduleAction
	22,  // 51: temporal.omes.kitchen_sink.Action.describe_schedule:type_name -> temporal.omes.kitchen_sink.DescribeScheduleAction
	23,  // 52: temporal.omes.kitchen_sink.Action.update_schedule:type_name -> temporal.omes.kitchen_sink.UpdateScheduleAction
	24,  // 53: temporal.omes.kitchen_sink.Action.delete_schedule:type_name -> temporal.omes.kitchen_sink.DeleteScheduleAction
	59,  // 54: temporal.omes.kitchen_sink.AwaitableChoice.wait_finish:type_name -> google.protobuf.Empty
	59,  // 55: temporal.omes.kitchen_sink.AwaitableChoice.abandon:type_name -> google.protobuf.Empty
	59,  // 56: temporal.omes.kitchen_sink.AwaitableChoice.cancel_before_started:type_name -> google.protobuf.Empty
	59,  // 57: temporal.omes.kitchen_sink.AwaitableChoice.cancel_after_started:type_name -> google.protobuf.Empty
	59,  // 58: temporal.omes.kitchen_sink.AwaitableChoice.cancel_after_completed:type_name -> google.protobuf.Empty
	26,  // 59: temporal.omes.kitchen_sink.TimerAction.awaitable_choice:type_name -> temporal.omes.kitchen_sink.AwaitableChoice
	43,  // 60: temporal.omes.kitchen_sink.ExecuteActivityAction.generic:type_name -> temporal.omes.kitchen_sink.ExecuteActivityAction.GenericActivity
	57,  // 61: temporal.omes.kitchen_sink.ExecuteActivityAction.delay:type_name -> google.protobuf.Duration
	59,  // 62: temporal.omes.kitchen_sink.ExecuteActivityAction.noop:type_name -> google.protobuf.Empty
	44,  // 63: temporal.omes.kitchen_sink.ExecuteActivityAction.resources:type_name -> temporal.omes.kitchen_sink.ExecuteActivityAction.ResourcesActivity
	45,  // 64: temporal.omes.kitchen_sink.ExecuteActivityAction.payload:type_name -> temporal.omes.kitchen_sink.ExecuteActivityAction.PayloadActivity
	46,  // 65: temporal.omes.kitchen_sink.ExecuteActivityAction.client:type_name -> temporal.omes.kitchen_sink.ExecuteActivityAction.ClientActivity
	47,  // 66: temporal.omes.kitchen_sink.ExecuteActivityAction.headers:type_name -> temporal.omes.kitchen_sink.ExecuteActivityAction.HeadersEntry
	57,  // 67: temporal.omes.kitchen_sink.ExecuteActivityAction.schedule_to_close_timeout:type_name -> google.protobuf.Duration
	57,  // 68: temporal.omes.kitchen_sink.ExecuteActivityAction.schedule_to_start_timeout:type_name -> google.protobuf.Duration
	57,  // 69: temporal.omes.kitchen_sink.ExecuteActivityAction.start_to_close_timeout:type_name -> google.protobuf.Duration
	57,  // 70: temporal.omes.kitchen_sink.ExecuteActivityAction.heartbeat_timeout:type_name -> google.protobuf.Duration
	61,  // 71: temporal.omes.kitchen_sink.ExecuteActivityAction.retry_policy:type_name -> temporal.api.common.v1.RetryPolicy
	59,  // 72: temporal.omes.kitchen_sink.ExecuteActivityAction.is_local:type_name -> google.protobuf.Empty
	39,  // 73: temporal.omes.kitchen_sink.ExecuteActivityAction.remote:type_name -> temporal.omes.kitchen_sink.RemoteActivityOptions
	26,  // 74: temporal.omes.kitchen_sink.ExecuteActivityAction.awaitable_choice:type_name -> temporal.omes.kitchen_sink.AwaitableChoice
	62,  // 75: temporal.omes.kitchen_sink.ExecuteActivityAction.priority:type_name -> temporal.api.common.v1.Priority
	60,  // 76: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.input:type_name -> temporal.api.common.v1.Payload
	57,  // 77: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.workflow_execution_timeout:type_name -> google.protobuf.Duration
	57,  // 78: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.workflow_run_timeout:type_name -> google.protobuf.Duration
	57,  // 79: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.workflow_task_timeout:type_name -> google.protobuf.Duration
	0,   // 80: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.parent_close_policy:type_name -> temporal.omes.kitchen_sink.ParentClosePolicy
	63,  // 81: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.workflow_id_reuse_policy:type_name -> temporal.api.enums.v1.WorkflowIdReusePolicy
	61,  // 82: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.retry_policy:type_name -> temporal.api.common.v1.RetryPolicy
	48,  // 83: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.headers:type_name -> temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.HeadersEntry
	49,  // 84: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.memo:type_name -> temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.MemoEntry
	50,  // 85: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.search_attributes:type_name -> temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.SearchAttributesEntry
	2,   // 86: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.cancellation_type:type_name -> temporal.omes.kitchen_sink.ChildWorkflowCancellationType
	1,   // 87: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.versioning_intent:type_name -> temporal.omes.kitchen_sink.VersioningIntent
	26,  // 88: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.awaitable_choice:type_name -> temporal.omes.kitchen_sink.AwaitableChoice
	60,  // 89: temporal.omes.kitchen_sink.SendSignalAction.args:type_name -> temporal.api.common.v1.Payload
	51,  // 90: temporal.omes.kitchen_sink.SendSignalAction.headers:type_name -> temporal.omes.kitchen_sink.SendSignalAction.HeadersEntry
	26,  // 91: temporal.omes.kitchen_sink.SendSignalAction.awaitable_choice:type_name -> temporal.omes.kitchen_sink.AwaitableChoice
	25,  // 92: temporal.omes.kitchen_sink.SetPatchMarkerAction.inner_action:type_name -> temporal.omes.kitchen_sink.Action
	52,  // 93: temporal.omes.kitchen_sink.UpsertSearchAttributesAction.search_attributes:type_name -> temporal.omes.kitchen_sink.UpsertSearchAttributesAction.SearchAttributesEntry
	64,  // 94: temporal.omes.kitchen_sink.UpsertMemoAction.upserted_memo:type_name -> temporal.api.common.v1.Memo
	60,  // 95: temporal.omes.kitchen_sink.ReturnResultAction.return_this:type_name -> temporal.api.common.v1.Payload
	65,  // 96: temporal.omes.kitchen_sink.ReturnErrorAction.failure:type_name -> temporal.api.failure.v1.Failure
	60,  // 97: temporal.omes.kitchen_sink.ContinueAsNewAction.arguments:type_name -> temporal.api.common.v1.Payload
	57,  // 98: temporal.omes.kitchen_sink.ContinueAsNewAction.workflow_run_timeout:type_name -> google.protobuf.Duration
	57,  // 99: temporal.omes.kitchen_sink.ContinueAsNewAction.workflow_task_timeout:type_name -> google.protobuf.Duration
	53,  // 100: temporal.omes.kitchen_sink.ContinueAsNewAction.memo:type_name -> temporal.omes.kitchen_sink.ContinueAsNewAction.MemoEntry
	54,  // 101: temporal.omes.kitchen_sink.ContinueAsNewAction.headers:type_name -> temporal.omes.kitchen_sink.ContinueAsNewAction.HeadersEntry
	55,  // 102: temporal.omes.kitchen_sink.ContinueAsNewAction.search_attributes:type_name -> temporal.omes.kitchen_sink.ContinueAsNewAction.SearchAttributesEntry
	61,  // 103: temporal.omes.kitchen_sink.ContinueAsNewAction.retry_policy:type_name -> temporal.api.common.v1.RetryPolicy
	1,   // 104: temporal.omes.kitchen_sink.ContinueAsNewAction.versioning_intent:type_name -> temporal.omes.kitchen_sink.VersioningIntent
	3,   // 105: temporal.omes.kitchen_sink.RemoteActivityOptions.cancellation_type:type_name -> temporal.omes.kitchen_sink.ActivityCancellationType
	1,   // 106: temporal.omes.kitchen_sink.RemoteActivityOptions.versioning_intent:type_name -> temporal.omes.kitchen_sink.VersioningIntent
	56,  // 107: temporal.omes.kitchen_sink.ExecuteNexusOperation.headers:type_name -> temporal.omes.kitchen_sink.ExecuteNexusOperation.HeadersEntry
	26,  // 108: temporal.omes.kitchen_sink.ExecuteNexusOperation.awaitable_choice:type_name -> temporal.omes.kitchen_sink.AwaitableChoice
	16,  // 109: temporal.omes.kitchen_sink.DoSignal.DoSignalActions.do_actions:type_name -> temporal.omes.kitchen_sink.ActionSet
	16,  // 110: temporal.omes.kitchen_sink.DoSignal.DoSignalActions.do_actions_in_main:type_name -> temporal.omes.kitchen_sink.ActionSet
	60,  // 111: temporal.omes.kitchen_sink.ExecuteActivityAction.GenericActivity.arguments:type_name -> temporal.api.common.v1.Payload
	57,  // 112: temporal.omes.kitchen_sink.ExecuteActivityAction.ResourcesActivity.run_for:type_name -> google.protobuf.Duration
	5,   // 113: temporal.omes.kitchen_sink.ExecuteActivityAction.ClientActivity.client_sequence:type_name -> temporal.omes.kitchen_sink.ClientSequence
	60,  // 114: temporal.omes.kitchen_sink.ExecuteActivityAction.HeadersEntry.value:type_name -> temporal.api.common.v1.Payload
	60,  // 115: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.HeadersEntry.value:type_name -> temporal.api.common.v1.Payload
	60,  // 116: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.MemoEntry.value:type_name -> temporal.api.common.v1.Payload
	60,  // 117: temporal.omes.kitchen_sink.ExecuteChildWorkflowAction.SearchAttributesEntry.value:type_name -> temporal.api.common.v1.Payload
	60,  // 118: temporal.omes.kitchen_sink.SendSignalAction.HeadersEntry.value:type_name -> temporal.api.common.v1.Payload
	60,  // 119: temporal.omes.kitchen_sink.UpsertSearchAttributesAction.SearchAttributesEntry.value:type_name -> temporal.api.common.v1.Payload
	60,  // 120: temporal.omes.kitchen_sink.ContinueAsNewAction.MemoEntry.value:type_name -> temporal.api.common.v1.Payload
	60,  // 121: temporal.omes.kitchen_sink.ContinueAsNewAction.HeadersEntry.value:type_name -> temporal.api.common.v1.Payload
	60,  // 122: temporal.omes.kitchen_sink.ContinueAsNewAction.SearchAttributesEntry.value:type_name -> temporal.api.common.v1.Payload
	123, // [123:123] is the sub-list for method output_type
	123, // [123:123] is the sub-list for method input_type
	123, // [123:123] is the sub-list for extension type_name
	123, // [123:123] is the sub-list for extension extendee
	0,   // [0:123] is the sub-list for field type_name
}

func init() { file_kitchen_sink_proto_init() }
func file_kitchen_sink_proto_init() {
	if File_kitchen_sink_proto != nil {
		return
	}
	file_kitchen_sink_proto_msgTypes[3].OneofWrappers = []any{
		(*WithStartClientAction_DoSignal)(nil),
		(*WithStartClientAction_DoUpdate)(nil),
	}
	file_kitchen_sink_proto_msgTypes[4].OneofWrappers = []any{
		(*ClientAction_DoSignal)(nil),
		(*ClientAction_DoQuery)(nil),
		(*ClientAction_DoUpdate)(nil),
		(*ClientAction_NestedActions)(nil),
	}
	file_kitchen_sink_proto_msgTypes[5].OneofWrappers = []any{
		(*DoSignal_DoSignalActions_)(nil),
		(*DoSignal_Custom)(nil),
	}
	file_kitchen_sink_proto_msgTypes[6].OneofWrappers = []any{
		(*DoQuery_ReportState)(nil),
		(*DoQuery_Custom)(nil),
	}
	file_kitchen_sink_proto_msgTypes[7].OneofWrappers = []any{
		(*DoUpdate_DoActions)(nil),
		(*DoUpdate_Custom)(nil),
	}
	file_kitchen_sink_proto_msgTypes[8].OneofWrappers = []any{
		(*DoActionsUpdate_DoActions)(nil),
		(*DoActionsUpdate_RejectMe)(nil),
	}
	file_kitchen_sink_proto_msgTypes[21].OneofWrappers = []any{
		(*Action_Timer)(nil),
		(*Action_ExecActivity)(nil),
		(*Action_ExecChildWorkflow)(nil),
		(*Action_AwaitWorkflowState)(nil),
		(*Action_SendSignal)(nil),
		(*Action_CancelWorkflow)(nil),
		(*Action_SetPatchMarker)(nil),
		(*Action_UpsertSearchAttributes)(nil),
		(*Action_UpsertMemo)(nil),
		(*Action_SetWorkflowState)(nil),
		(*Action_ReturnResult)(nil),
		(*Action_ReturnError)(nil),
		(*Action_ContinueAsNew)(nil),
		(*Action_NestedActionSet)(nil),
		(*Action_NexusOperation)(nil),
		(*Action_CreateSchedule)(nil),
		(*Action_DescribeSchedule)(nil),
		(*Action_UpdateSchedule)(nil),
		(*Action_DeleteSchedule)(nil),
	}
	file_kitchen_sink_proto_msgTypes[22].OneofWrappers = []any{
		(*AwaitableChoice_WaitFinish)(nil),
		(*AwaitableChoice_Abandon)(nil),
		(*AwaitableChoice_CancelBeforeStarted)(nil),
		(*AwaitableChoice_CancelAfterStarted)(nil),
		(*AwaitableChoice_CancelAfterCompleted)(nil),
	}
	file_kitchen_sink_proto_msgTypes[24].OneofWrappers = []any{
		(*ExecuteActivityAction_Generic)(nil),
		(*ExecuteActivityAction_Delay)(nil),
		(*ExecuteActivityAction_Noop)(nil),
		(*ExecuteActivityAction_Resources)(nil),
		(*ExecuteActivityAction_Payload)(nil),
		(*ExecuteActivityAction_Client)(nil),
		(*ExecuteActivityAction_IsLocal)(nil),
		(*ExecuteActivityAction_Remote)(nil),
	}
	file_kitchen_sink_proto_msgTypes[37].OneofWrappers = []any{
		(*DoSignal_DoSignalActions_DoActions)(nil),
		(*DoSignal_DoSignalActions_DoActionsInMain)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_kitchen_sink_proto_rawDesc), len(file_kitchen_sink_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   53,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_kitchen_sink_proto_goTypes,
		DependencyIndexes: file_kitchen_sink_proto_depIdxs,
		EnumInfos:         file_kitchen_sink_proto_enumTypes,
		MessageInfos:      file_kitchen_sink_proto_msgTypes,
	}.Build()
	File_kitchen_sink_proto = out.File
	file_kitchen_sink_proto_goTypes = nil
	file_kitchen_sink_proto_depIdxs = nil
}
